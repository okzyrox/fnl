# Fast Noise Lite for Nim

import std/[math]

type FnlFloat = float32 # alternate to float64

type FnlNoiseType* = enum
    OpenSimplex2
    OpenSimplex2S
    Cellular
    Perlin
    ValueCubic
    Value

type FnlRotationType* = enum
    None
    ImproveXYPlanes
    ImproveXZPlanes

type FnlFractalType* = enum
    None
    FBm
    Ridged
    PingPong
    DomainWarpProgressive
    DomainWarpIndependent

type FnlCellularDistanceFunction* = enum
    Euclidean
    EuclideanSq
    Manhattan
    Hybrid

type FnlCellularReturnType* = enum
    CellValue
    Distance
    Distance2
    Distance2Add
    Distance2Sub
    Distance2Mul
    Distance2Div

type FnlDomainWarpType* = enum
    OpenSimplex2
    OpenSimplex2Reduced
    BasicGrid

type FnlTransformType* = enum
    None
    ImproveXYPlanes
    ImproveXZPlanes
    DefaultOpenSimplex2

# FastNoiseLite

type FnlNoise* = object
    seed: int = 1337
    frequency: float = 0.01
    noiseType: FnlNoiseType = FnlNoiseType.OpenSimplex2
    rotationType: FnlRotationType = FnlRotationType.None
    transformType: FnlTransformType = FnlTransformType.DefaultOpenSimplex2

    fractalType: FnlFractalType = FnlFractalType.None
    
    octaves: int = 3
    lacunarity: float = 2.0
    gain: float = 0.5
    weightedStrength: float = 0.0
    pingPongStrength: float = 2.0

    fractalBounding: float = 1 / 1.75

    cellularDistanceFunction: FnlCellularDistanceFunction = FnlCellularDistanceFunction.Euclidean
    cellularReturnType: FnlCellularReturnType = FnlCellularReturnType.Distance
    cellularJitterModifier: float = 1.0

    domainWarpType: FnlDomainWarpType = FnlDomainWarpType.OpenSimplex2
    warpTransformType: FnlTransformType = FnlTransformType.DefaultOpenSimplex2
    domainWarpAmp: float = 1.0

const
    # 2D
    Gradients2D = [
        0.130526192220052f,  0.99144486137381f,   0.38268343236509f,   0.923879532511287f,  0.608761429008721f,  0.793353340291235f,  0.793353340291235f,  0.608761429008721f,
         0.923879532511287f,  0.38268343236509f,   0.99144486137381f,   0.130526192220051f,  0.99144486137381f,  -0.130526192220051f,  0.923879532511287f, -0.38268343236509f,
         0.793353340291235f, -0.60876142900872f,   0.608761429008721f, -0.793353340291235f,  0.38268343236509f,  -0.923879532511287f,  0.130526192220052f, -0.99144486137381f,
        -0.130526192220052f, -0.99144486137381f,  -0.38268343236509f,  -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
        -0.923879532511287f, -0.38268343236509f,  -0.99144486137381f,  -0.130526192220052f, -0.99144486137381f,   0.130526192220051f, -0.923879532511287f,  0.38268343236509f,
        -0.793353340291235f,  0.608761429008721f, -0.608761429008721f,  0.793353340291235f, -0.38268343236509f,   0.923879532511287f, -0.130526192220052f,  0.99144486137381f,
         0.130526192220052f,  0.99144486137381f,   0.38268343236509f,   0.923879532511287f,  0.608761429008721f,  0.793353340291235f,  0.793353340291235f,  0.608761429008721f,
         0.923879532511287f,  0.38268343236509f,   0.99144486137381f,   0.130526192220051f,  0.99144486137381f,  -0.130526192220051f,  0.923879532511287f, -0.38268343236509f,
         0.793353340291235f, -0.60876142900872f,   0.608761429008721f, -0.793353340291235f,  0.38268343236509f,  -0.923879532511287f,  0.130526192220052f, -0.99144486137381f,
        -0.130526192220052f, -0.99144486137381f,  -0.38268343236509f,  -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
        -0.923879532511287f, -0.38268343236509f,  -0.99144486137381f,  -0.130526192220052f, -0.99144486137381f,   0.130526192220051f, -0.923879532511287f,  0.38268343236509f,
        -0.793353340291235f,  0.608761429008721f, -0.608761429008721f,  0.793353340291235f, -0.38268343236509f,   0.923879532511287f, -0.130526192220052f,  0.99144486137381f,
         0.130526192220052f,  0.99144486137381f,   0.38268343236509f,   0.923879532511287f,  0.608761429008721f,  0.793353340291235f,  0.793353340291235f,  0.608761429008721f,
         0.923879532511287f,  0.38268343236509f,   0.99144486137381f,   0.130526192220051f,  0.99144486137381f,  -0.130526192220051f,  0.923879532511287f, -0.38268343236509f,
         0.793353340291235f, -0.60876142900872f,   0.608761429008721f, -0.793353340291235f,  0.38268343236509f,  -0.923879532511287f,  0.130526192220052f, -0.99144486137381f,
        -0.130526192220052f, -0.99144486137381f,  -0.38268343236509f,  -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
        -0.923879532511287f, -0.38268343236509f,  -0.99144486137381f,  -0.130526192220052f, -0.99144486137381f,   0.130526192220051f, -0.923879532511287f,  0.38268343236509f,
        -0.793353340291235f,  0.608761429008721f, -0.608761429008721f,  0.793353340291235f, -0.38268343236509f,   0.923879532511287f, -0.130526192220052f,  0.99144486137381f,
         0.130526192220052f,  0.99144486137381f,   0.38268343236509f,   0.923879532511287f,  0.608761429008721f,  0.793353340291235f,  0.793353340291235f,  0.608761429008721f,
         0.923879532511287f,  0.38268343236509f,   0.99144486137381f,   0.130526192220051f,  0.99144486137381f,  -0.130526192220051f,  0.923879532511287f, -0.38268343236509f,
         0.793353340291235f, -0.60876142900872f,   0.608761429008721f, -0.793353340291235f,  0.38268343236509f,  -0.923879532511287f,  0.130526192220052f, -0.99144486137381f,
        -0.130526192220052f, -0.99144486137381f,  -0.38268343236509f,  -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
        -0.923879532511287f, -0.38268343236509f,  -0.99144486137381f,  -0.130526192220052f, -0.99144486137381f,   0.130526192220051f, -0.923879532511287f,  0.38268343236509f,
        -0.793353340291235f,  0.608761429008721f, -0.608761429008721f,  0.793353340291235f, -0.38268343236509f,   0.923879532511287f, -0.130526192220052f,  0.99144486137381f,
         0.130526192220052f,  0.99144486137381f,   0.38268343236509f,   0.923879532511287f,  0.608761429008721f,  0.793353340291235f,  0.793353340291235f,  0.608761429008721f,
         0.923879532511287f,  0.38268343236509f,   0.99144486137381f,   0.130526192220051f,  0.99144486137381f,  -0.130526192220051f,  0.923879532511287f, -0.38268343236509f,
         0.793353340291235f, -0.60876142900872f,   0.608761429008721f, -0.793353340291235f,  0.38268343236509f,  -0.923879532511287f,  0.130526192220052f, -0.99144486137381f,
        -0.130526192220052f, -0.99144486137381f,  -0.38268343236509f,  -0.923879532511287f, -0.608761429008721f, -0.793353340291235f, -0.793353340291235f, -0.608761429008721f,
        -0.923879532511287f, -0.38268343236509f,  -0.99144486137381f,  -0.130526192220052f, -0.99144486137381f,   0.130526192220051f, -0.923879532511287f,  0.38268343236509f,
        -0.793353340291235f,  0.608761429008721f, -0.608761429008721f,  0.793353340291235f, -0.38268343236509f,   0.923879532511287f, -0.130526192220052f,  0.99144486137381f,
         0.38268343236509f,   0.923879532511287f,  0.923879532511287f,  0.38268343236509f,   0.923879532511287f, -0.38268343236509f,   0.38268343236509f,  -0.923879532511287f,
        -0.38268343236509f,  -0.923879532511287f, -0.923879532511287f, -0.38268343236509f,  -0.923879532511287f,  0.38268343236509f,  -0.38268343236509f,   0.923879532511287f
    ]
    RandVecs2D = [
        -0.2700222198f, -0.9628540911f, 0.3863092627f, -0.9223693152f, 0.04444859006f, -0.999011673f, -0.5992523158f, -0.8005602176f, -0.7819280288f, 0.6233687174f, 0.9464672271f, 0.3227999196f, -0.6514146797f, -0.7587218957f, 0.9378472289f, 0.347048376f,
        -0.8497875957f, -0.5271252623f, -0.879042592f, 0.4767432447f, -0.892300288f, -0.4514423508f, -0.379844434f, -0.9250503802f, -0.9951650832f, 0.0982163789f, 0.7724397808f, -0.6350880136f, 0.7573283322f, -0.6530343002f, -0.9928004525f, -0.119780055f,
        -0.0532665713f, 0.9985803285f, 0.9754253726f, -0.2203300762f, -0.7665018163f, 0.6422421394f, 0.991636706f, 0.1290606184f, -0.994696838f, 0.1028503788f, -0.5379205513f, -0.84299554f, 0.5022815471f, -0.8647041387f, 0.4559821461f, -0.8899889226f,
        -0.8659131224f, -0.5001944266f, 0.0879458407f, -0.9961252577f, -0.5051684983f, 0.8630207346f, 0.7753185226f, -0.6315704146f, -0.6921944612f, 0.7217110418f, -0.5191659449f, -0.8546734591f, 0.8978622882f, -0.4402764035f, -0.1706774107f, 0.9853269617f,
        -0.9353430106f, -0.3537420705f, -0.9992404798f, 0.03896746794f, -0.2882064021f, -0.9575683108f, -0.9663811329f, 0.2571137995f, -0.8759714238f, -0.4823630009f, -0.8303123018f, -0.5572983775f, 0.05110133755f, -0.9986934731f, -0.8558373281f, -0.5172450752f,
        0.09887025282f, 0.9951003332f, 0.9189016087f, 0.3944867976f, -0.2439375892f, -0.9697909324f, -0.8121409387f, -0.5834613061f, -0.9910431363f, 0.1335421355f, 0.8492423985f, -0.5280031709f, -0.9717838994f, -0.2358729591f, 0.9949457207f, 0.1004142068f,
        0.6241065508f, -0.7813392434f, 0.662910307f, 0.7486988212f, -0.7197418176f, 0.6942418282f, -0.8143370775f, -0.5803922158f, 0.104521054f, -0.9945226741f, -0.1065926113f, -0.9943027784f, 0.445799684f, -0.8951327509f, 0.105547406f, 0.9944142724f,
        -0.992790267f, 0.1198644477f, -0.8334366408f, 0.552615025f, 0.9115561563f, -0.4111755999f, 0.8285544909f, -0.5599084351f, 0.7217097654f, -0.6921957921f, 0.4940492677f, -0.8694339084f, -0.3652321272f, -0.9309164803f, -0.9696606758f, 0.2444548501f,
        0.08925509731f, -0.996008799f, 0.5354071276f, -0.8445941083f, -0.1053576186f, 0.9944343981f, -0.9890284586f, 0.1477251101f, 0.004856104961f, 0.9999882091f, 0.9885598478f, 0.1508291331f, 0.9286129562f, -0.3710498316f, -0.5832393863f, -0.8123003252f,
        0.3015207509f, 0.9534596146f, -0.9575110528f, 0.2883965738f, 0.9715802154f, -0.2367105511f, 0.229981792f, 0.9731949318f, 0.955763816f, -0.2941352207f, 0.740956116f, 0.6715534485f, -0.9971513787f, -0.07542630764f, 0.6905710663f, -0.7232645452f,
        -0.290713703f, -0.9568100872f, 0.5912777791f, -0.8064679708f, -0.9454592212f, -0.325740481f, 0.6664455681f, 0.74555369f, 0.6236134912f, 0.7817328275f, 0.9126993851f, -0.4086316587f, -0.8191762011f, 0.5735419353f, -0.8812745759f, -0.4726046147f,
        0.9953313627f, 0.09651672651f, 0.9855650846f, -0.1692969699f, -0.8495980887f, 0.5274306472f, 0.6174853946f, -0.7865823463f, 0.8508156371f, 0.52546432f, 0.9985032451f, -0.05469249926f, 0.1971371563f, -0.9803759185f, 0.6607855748f, -0.7505747292f,
        -0.03097494063f, 0.9995201614f, -0.6731660801f, 0.739491331f, -0.7195018362f, -0.6944905383f, 0.9727511689f, 0.2318515979f, 0.9997059088f, -0.0242506907f, 0.4421787429f, -0.8969269532f, 0.9981350961f, -0.061043673f, -0.9173660799f, -0.3980445648f,
        -0.8150056635f, -0.5794529907f, -0.8789331304f, 0.4769450202f, 0.0158605829f, 0.999874213f, -0.8095464474f, 0.5870558317f, -0.9165898907f, -0.3998286786f, -0.8023542565f, 0.5968480938f, -0.5176737917f, 0.8555780767f, -0.8154407307f, -0.5788405779f,
        0.4022010347f, -0.9155513791f, -0.9052556868f, -0.4248672045f, 0.7317445619f, 0.6815789728f, -0.5647632201f, -0.8252529947f, -0.8403276335f, -0.5420788397f, -0.9314281527f, 0.363925262f, 0.5238198472f, 0.8518290719f, 0.7432803869f, -0.6689800195f,
        -0.985371561f, -0.1704197369f, 0.4601468731f, 0.88784281f, 0.825855404f, 0.5638819483f, 0.6182366099f, 0.7859920446f, 0.8331502863f, -0.553046653f, 0.1500307506f, 0.9886813308f, -0.662330369f, -0.7492119075f, -0.668598664f, 0.743623444f,
        0.7025606278f, 0.7116238924f, -0.5419389763f, -0.8404178401f, -0.3388616456f, 0.9408362159f, 0.8331530315f, 0.5530425174f, -0.2989720662f, -0.9542618632f, 0.2638522993f, 0.9645630949f, 0.124108739f, -0.9922686234f, -0.7282649308f, -0.6852956957f,
        0.6962500149f, 0.7177993569f, -0.9183535368f, 0.3957610156f, -0.6326102274f, -0.7744703352f, -0.9331891859f, -0.359385508f, -0.1153779357f, -0.9933216659f, 0.9514974788f, -0.3076565421f, -0.08987977445f, -0.9959526224f, 0.6678496916f, 0.7442961705f,
        0.7952400393f, -0.6062947138f, -0.6462007402f, -0.7631674805f, -0.2733598753f, 0.9619118351f, 0.9669590226f, -0.254931851f, -0.9792894595f, 0.2024651934f, -0.5369502995f, -0.8436138784f, -0.270036471f, -0.9628500944f, -0.6400277131f, 0.7683518247f,
        -0.7854537493f, -0.6189203566f, 0.06005905383f, -0.9981948257f, -0.02455770378f, 0.9996984141f, -0.65983623f, 0.751409442f, -0.6253894466f, -0.7803127835f, -0.6210408851f, -0.7837781695f, 0.8348888491f, 0.5504185768f, -0.1592275245f, 0.9872419133f,
        0.8367622488f, 0.5475663786f, -0.8675753916f, -0.4973056806f, -0.2022662628f, -0.9793305667f, 0.9399189937f, 0.3413975472f, 0.9877404807f, -0.1561049093f, -0.9034455656f, 0.4287028224f, 0.1269804218f, -0.9919052235f, -0.3819600854f, 0.924178821f,
        0.9754625894f, 0.2201652486f, -0.3204015856f, -0.9472818081f, -0.9874760884f, 0.1577687387f, 0.02535348474f, -0.9996785487f, 0.4835130794f, -0.8753371362f, -0.2850799925f, -0.9585037287f, -0.06805516006f, -0.99768156f, -0.7885244045f, -0.6150034663f,
        0.3185392127f, -0.9479096845f, 0.8880043089f, 0.4598351306f, 0.6476921488f, -0.7619021462f, 0.9820241299f, 0.1887554194f, 0.9357275128f, -0.3527237187f, -0.8894895414f, 0.4569555293f, 0.7922791302f, 0.6101588153f, 0.7483818261f, 0.6632681526f,
        -0.7288929755f, -0.6846276581f, 0.8729032783f, -0.4878932944f, 0.8288345784f, 0.5594937369f, 0.08074567077f, 0.9967347374f, 0.9799148216f, -0.1994165048f, -0.580730673f, -0.8140957471f, -0.4700049791f, -0.8826637636f, 0.2409492979f, 0.9705377045f,
        0.9437816757f, -0.3305694308f, -0.8927998638f, -0.4504535528f, -0.8069622304f, 0.5906030467f, 0.06258973166f, 0.9980393407f, -0.9312597469f, 0.3643559849f, 0.5777449785f, 0.8162173362f, -0.3360095855f, -0.941858566f, 0.697932075f, -0.7161639607f,
        -0.002008157227f, -0.9999979837f, -0.1827294312f, -0.9831632392f, -0.6523911722f, 0.7578824173f, -0.4302626911f, -0.9027037258f, -0.9985126289f, -0.05452091251f, -0.01028102172f, -0.9999471489f, -0.4946071129f, 0.8691166802f, -0.2999350194f, 0.9539596344f,
        0.8165471961f, 0.5772786819f, 0.2697460475f, 0.962931498f, -0.7306287391f, -0.6827749597f, -0.7590952064f, -0.6509796216f, -0.907053853f, 0.4210146171f, -0.5104861064f, -0.8598860013f, 0.8613350597f, 0.5080373165f, 0.5007881595f, -0.8655698812f,
        -0.654158152f, 0.7563577938f, -0.8382755311f, -0.545246856f, 0.6940070834f, 0.7199681717f, 0.06950936031f, 0.9975812994f, 0.1702942185f, -0.9853932612f, 0.2695973274f, 0.9629731466f, 0.5519612192f, -0.8338697815f, 0.225657487f, -0.9742067022f,
        0.4215262855f, -0.9068161835f, 0.4881873305f, -0.8727388672f, -0.3683854996f, -0.9296731273f, -0.9825390578f, 0.1860564427f, 0.81256471f, 0.5828709909f, 0.3196460933f, -0.9475370046f, 0.9570913859f, 0.2897862643f, -0.6876655497f, -0.7260276109f,
        -0.9988770922f, -0.047376731f, -0.1250179027f, 0.992154486f, -0.8280133617f, 0.560708367f, 0.9324863769f, -0.3612051451f, 0.6394653183f, 0.7688199442f, -0.01623847064f, -0.9998681473f, -0.9955014666f, -0.09474613458f, -0.81453315f, 0.580117012f,
        0.4037327978f, -0.9148769469f, 0.9944263371f, 0.1054336766f, -0.1624711654f, 0.9867132919f, -0.9949487814f, -0.100383875f, -0.6995302564f, 0.7146029809f, 0.5263414922f, -0.85027327f, -0.5395221479f, 0.841971408f, 0.6579370318f, 0.7530729462f,
        0.01426758847f, -0.9998982128f, -0.6734383991f, 0.7392433447f, 0.639412098f, -0.7688642071f, 0.9211571421f, 0.3891908523f, -0.146637214f, -0.9891903394f, -0.782318098f, 0.6228791163f, -0.5039610839f, -0.8637263605f, -0.7743120191f, -0.6328039957f
    ]

    # 3D

    Gradients3D = [
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        1, 1, 0, 0,  0,-1, 1, 0, -1, 1, 0, 0,  0,-1,-1, 0
    ]

    RandVecs3D = [
        -0.7292736885f, -0.6618439697f, 0.1735581948f, 0, 0.790292081f, -0.5480887466f, -0.2739291014f, 0, 0.7217578935f, 0.6226212466f, -0.3023380997f, 0, 0.565683137f, -0.8208298145f, -0.0790000257f, 0, 0.760049034f, -0.5555979497f, -0.3370999617f, 0, 0.3713945616f, 0.5011264475f, 0.7816254623f, 0, -0.1277062463f, -0.4254438999f, -0.8959289049f, 0, -0.2881560924f, -0.5815838982f, 0.7607405838f, 0,
        0.5849561111f, -0.662820239f, -0.4674352136f, 0, 0.3307171178f, 0.0391653737f, 0.94291689f, 0, 0.8712121778f, -0.4113374369f, -0.2679381538f, 0, 0.580981015f, 0.7021915846f, 0.4115677815f, 0, 0.503756873f, 0.6330056931f, -0.5878203852f, 0, 0.4493712205f, 0.601390195f, 0.6606022552f, 0, -0.6878403724f, 0.09018890807f, -0.7202371714f, 0, -0.5958956522f, -0.6469350577f, 0.475797649f, 0,
        -0.5127052122f, 0.1946921978f, -0.8361987284f, 0, -0.9911507142f, -0.05410276466f, -0.1212153153f, 0, -0.2149721042f, 0.9720882117f, -0.09397607749f, 0, -0.7518650936f, -0.5428057603f, 0.3742469607f, 0, 0.5237068895f, 0.8516377189f, -0.02107817834f, 0, 0.6333504779f, 0.1926167129f, -0.7495104896f, 0, -0.06788241606f, 0.3998305789f, 0.9140719259f, 0, -0.5538628599f, -0.4729896695f, -0.6852128902f, 0,
        -0.7261455366f, -0.5911990757f, 0.3509933228f, 0, -0.9229274737f, -0.1782808786f, 0.3412049336f, 0, -0.6968815002f, 0.6511274338f, 0.3006480328f, 0, 0.9608044783f, -0.2098363234f, -0.1811724921f, 0, 0.06817146062f, -0.9743405129f, 0.2145069156f, 0, -0.3577285196f, -0.6697087264f, -0.6507845481f, 0, -0.1868621131f, 0.7648617052f, -0.6164974636f, 0, -0.6541697588f, 0.3967914832f, 0.6439087246f, 0,
        0.6993340405f, -0.6164538506f, 0.3618239211f, 0, -0.1546665739f, 0.6291283928f, 0.7617583057f, 0, -0.6841612949f, -0.2580482182f, -0.6821542638f, 0, 0.5383980957f, 0.4258654885f, 0.7271630328f, 0, -0.5026987823f, -0.7939832935f, -0.3418836993f, 0, 0.3202971715f, 0.2834415347f, 0.9039195862f, 0, 0.8683227101f, -0.0003762656404f, -0.4959995258f, 0, 0.791120031f, -0.08511045745f, 0.6057105799f, 0,
        -0.04011016052f, -0.4397248749f, 0.8972364289f, 0, 0.9145119872f, 0.3579346169f, -0.1885487608f, 0, -0.9612039066f, -0.2756484276f, 0.01024666929f, 0, 0.6510361721f, -0.2877799159f, -0.7023778346f, 0, -0.2041786351f, 0.7365237271f, 0.644859585f, 0, -0.7718263711f, 0.3790626912f, 0.5104855816f, 0, -0.3060082741f, -0.7692987727f, 0.5608371729f, 0, 0.454007341f, -0.5024843065f, 0.7357899537f, 0,
        0.4816795475f, 0.6021208291f, -0.6367380315f, 0, 0.6961980369f, -0.3222197429f, 0.641469197f, 0, -0.6532160499f, -0.6781148932f, 0.3368515753f, 0, 0.5089301236f, -0.6154662304f, -0.6018234363f, 0, -0.1635919754f, -0.9133604627f, -0.372840892f, 0, 0.52408019f, -0.8437664109f, 0.1157505864f, 0, 0.5902587356f, 0.4983817807f, -0.6349883666f, 0, 0.5863227872f, 0.494764745f, 0.6414307729f, 0,
        0.6779335087f, 0.2341345225f, 0.6968408593f, 0, 0.7177054546f, -0.6858979348f, 0.120178631f, 0, -0.5328819713f, -0.5205125012f, 0.6671608058f, 0, -0.8654874251f, -0.0700727088f, -0.4960053754f, 0, -0.2861810166f, 0.7952089234f, 0.5345495242f, 0, -0.04849529634f, 0.9810836427f, -0.1874115585f, 0, -0.6358521667f, 0.6058348682f, 0.4781800233f, 0, 0.6254794696f, -0.2861619734f, 0.7258696564f, 0,
        -0.2585259868f, 0.5061949264f, -0.8227581726f, 0, 0.02136306781f, 0.5064016808f, -0.8620330371f, 0, 0.200111773f, 0.8599263484f, 0.4695550591f, 0, 0.4743561372f, 0.6014985084f, -0.6427953014f, 0, 0.6622993731f, -0.5202474575f, -0.5391679918f, 0, 0.08084972818f, -0.6532720452f, 0.7527940996f, 0, -0.6893687501f, 0.0592860349f, 0.7219805347f, 0, -0.1121887082f, -0.9673185067f, 0.2273952515f, 0,
        0.7344116094f, 0.5979668656f, -0.3210532909f, 0, 0.5789393465f, -0.2488849713f, 0.7764570201f, 0, 0.6988182827f, 0.3557169806f, -0.6205791146f, 0, -0.8636845529f, -0.2748771249f, -0.4224826141f, 0, -0.4247027957f, -0.4640880967f, 0.777335046f, 0, 0.5257722489f, -0.8427017621f, 0.1158329937f, 0, 0.9343830603f, 0.316302472f, -0.1639543925f, 0, -0.1016836419f, -0.8057303073f, -0.5834887393f, 0,
        -0.6529238969f, 0.50602126f, -0.5635892736f, 0, -0.2465286165f, -0.9668205684f, -0.06694497494f, 0, -0.9776897119f, -0.2099250524f, -0.007368825344f, 0, 0.7736893337f, 0.5734244712f, 0.2694238123f, 0, -0.6095087895f, 0.4995678998f, 0.6155736747f, 0, 0.5794535482f, 0.7434546771f, 0.3339292269f, 0, -0.8226211154f, 0.08142581855f, 0.5627293636f, 0, -0.510385483f, 0.4703667658f, 0.7199039967f, 0,
        -0.5764971849f, -0.07231656274f, -0.8138926898f, 0, 0.7250628871f, 0.3949971505f, -0.5641463116f, 0, -0.1525424005f, 0.4860840828f, -0.8604958341f, 0, -0.5550976208f, -0.4957820792f, 0.667882296f, 0, -0.1883614327f, 0.9145869398f, 0.357841725f, 0, 0.7625556724f, -0.5414408243f, -0.3540489801f, 0, -0.5870231946f, -0.3226498013f, -0.7424963803f, 0, 0.3051124198f, 0.2262544068f, -0.9250488391f, 0,
        0.6379576059f, 0.577242424f, -0.5097070502f, 0, -0.5966775796f, 0.1454852398f, -0.7891830656f, 0, -0.658330573f, 0.6555487542f, -0.3699414651f, 0, 0.7434892426f, 0.2351084581f, 0.6260573129f, 0, 0.5562114096f, 0.8264360377f, -0.0873632843f, 0, -0.3028940016f, -0.8251527185f, 0.4768419182f, 0, 0.1129343818f, -0.985888439f, -0.1235710781f, 0, 0.5937652891f, -0.5896813806f, 0.5474656618f, 0,
        0.6757964092f, -0.5835758614f, -0.4502648413f, 0, 0.7242302609f, -0.1152719764f, 0.6798550586f, 0, -0.9511914166f, 0.0753623979f, -0.2992580792f, 0, 0.2539470961f, -0.1886339355f, 0.9486454084f, 0, 0.571433621f, -0.1679450851f, -0.8032795685f, 0, -0.06778234979f, 0.3978269256f, 0.9149531629f, 0, 0.6074972649f, 0.733060024f, -0.3058922593f, 0, -0.5435478392f, 0.1675822484f, 0.8224791405f, 0,
        -0.5876678086f, -0.3380045064f, -0.7351186982f, 0, -0.7967562402f, 0.04097822706f, -0.6029098428f, 0, -0.1996350917f, 0.8706294745f, 0.4496111079f, 0, -0.02787660336f, -0.9106232682f, -0.4122962022f, 0, -0.7797625996f, -0.6257634692f, 0.01975775581f, 0, -0.5211232846f, 0.7401644346f, -0.4249554471f, 0, 0.8575424857f, 0.4053272873f, -0.3167501783f, 0, 0.1045223322f, 0.8390195772f, -0.5339674439f, 0,
        0.3501822831f, 0.9242524096f, -0.1520850155f, 0, 0.1987849858f, 0.07647613266f, 0.9770547224f, 0, 0.7845996363f, 0.6066256811f, -0.1280964233f, 0, 0.09006737436f, -0.9750989929f, -0.2026569073f, 0, -0.8274343547f, -0.542299559f, 0.1458203587f, 0, -0.3485797732f, -0.415802277f, 0.840000362f, 0, -0.2471778936f, -0.7304819962f, -0.6366310879f, 0, -0.3700154943f, 0.8577948156f, 0.3567584454f, 0,
        0.5913394901f, -0.548311967f, -0.5913303597f, 0, 0.1204873514f, -0.7626472379f, -0.6354935001f, 0, 0.616959265f, 0.03079647928f, 0.7863922953f, 0, 0.1258156836f, -0.6640829889f, -0.7369967419f, 0, -0.6477565124f, -0.1740147258f, -0.7417077429f, 0, 0.6217889313f, -0.7804430448f, -0.06547655076f, 0, 0.6589943422f, -0.6096987708f, 0.4404473475f, 0, -0.2689837504f, -0.6732403169f, -0.6887635427f, 0,
        -0.3849775103f, 0.5676542638f, 0.7277093879f, 0, 0.5754444408f, 0.8110471154f, -0.1051963504f, 0, 0.9141593684f, 0.3832947817f, 0.131900567f, 0, -0.107925319f, 0.9245493968f, 0.3654593525f, 0, 0.377977089f, 0.3043148782f, 0.8743716458f, 0, -0.2142885215f, -0.8259286236f, 0.5214617324f, 0, 0.5802544474f, 0.4148098596f, -0.7008834116f, 0, -0.1982660881f, 0.8567161266f, -0.4761596756f, 0,
        -0.03381553704f, 0.3773180787f, -0.9254661404f, 0, -0.6867922841f, -0.6656597827f, 0.2919133642f, 0, 0.7731742607f, -0.2875793547f, -0.5652430251f, 0, -0.09655941928f, 0.9193708367f, -0.3813575004f, 0, 0.2715702457f, -0.9577909544f, -0.09426605581f, 0, 0.2451015704f, -0.6917998565f, -0.6792188003f, 0, 0.977700782f, -0.1753855374f, 0.1155036542f, 0, -0.5224739938f, 0.8521606816f, 0.02903615945f, 0,
        -0.7734880599f, -0.5261292347f, 0.3534179531f, 0, -0.7134492443f, -0.269547243f, 0.6467878011f, 0, 0.1644037271f, 0.5105846203f, -0.8439637196f, 0, 0.6494635788f, 0.05585611296f, 0.7583384168f, 0, -0.4711970882f, 0.5017280509f, -0.7254255765f, 0, -0.6335764307f, -0.2381686273f, -0.7361091029f, 0, -0.9021533097f, -0.270947803f, -0.3357181763f, 0, -0.3793711033f, 0.872258117f, 0.3086152025f, 0,
        -0.6855598966f, -0.3250143309f, 0.6514394162f, 0, 0.2900942212f, -0.7799057743f, -0.5546100667f, 0, -0.2098319339f, 0.85037073f, 0.4825351604f, 0, -0.4592603758f, 0.6598504336f, -0.5947077538f, 0, 0.8715945488f, 0.09616365406f, -0.4807031248f, 0, -0.6776666319f, 0.7118504878f, -0.1844907016f, 0, 0.7044377633f, 0.312427597f, 0.637304036f, 0, -0.7052318886f, -0.2401093292f, -0.6670798253f, 0,
        0.081921007f, -0.7207336136f, -0.6883545647f, 0, -0.6993680906f, -0.5875763221f, -0.4069869034f, 0, -0.1281454481f, 0.6419895885f, 0.7559286424f, 0, -0.6337388239f, -0.6785471501f, -0.3714146849f, 0, 0.5565051903f, -0.2168887573f, -0.8020356851f, 0, -0.5791554484f, 0.7244372011f, -0.3738578718f, 0, 0.1175779076f, -0.7096451073f, 0.6946792478f, 0, -0.6134619607f, 0.1323631078f, 0.7785527795f, 0,
        0.6984635305f, -0.02980516237f, -0.715024719f, 0, 0.8318082963f, -0.3930171956f, 0.3919597455f, 0, 0.1469576422f, 0.05541651717f, -0.9875892167f, 0, 0.708868575f, -0.2690503865f, 0.6520101478f, 0, 0.2726053183f, 0.67369766f, -0.68688995f, 0, -0.6591295371f, 0.3035458599f, -0.6880466294f, 0, 0.4815131379f, -0.7528270071f, 0.4487723203f, 0, 0.9430009463f, 0.1675647412f, -0.2875261255f, 0,
        0.434802957f, 0.7695304522f, -0.4677277752f, 0, 0.3931996188f, 0.594473625f, 0.7014236729f, 0, 0.7254336655f, -0.603925654f, 0.3301814672f, 0, 0.7590235227f, -0.6506083235f, 0.02433313207f, 0, -0.8552768592f, -0.3430042733f, 0.3883935666f, 0, -0.6139746835f, 0.6981725247f, 0.3682257648f, 0, -0.7465905486f, -0.5752009504f, 0.3342849376f, 0, 0.5730065677f, 0.810555537f, -0.1210916791f, 0,
        -0.9225877367f, -0.3475211012f, -0.167514036f, 0, -0.7105816789f, -0.4719692027f, -0.5218416899f, 0, -0.08564609717f, 0.3583001386f, 0.929669703f, 0, -0.8279697606f, -0.2043157126f, 0.5222271202f, 0, 0.427944023f, 0.278165994f, 0.8599346446f, 0, 0.5399079671f, -0.7857120652f, -0.3019204161f, 0, 0.5678404253f, -0.5495413974f, -0.6128307303f, 0, -0.9896071041f, 0.1365639107f, -0.04503418428f, 0,
        -0.6154342638f, -0.6440875597f, 0.4543037336f, 0, 0.1074204368f, -0.7946340692f, 0.5975094525f, 0, -0.3595449969f, -0.8885529948f, 0.28495784f, 0, -0.2180405296f, 0.1529888965f, 0.9638738118f, 0, -0.7277432317f, -0.6164050508f, -0.3007234646f, 0, 0.7249729114f, -0.00669719484f, 0.6887448187f, 0, -0.5553659455f, -0.5336586252f, 0.6377908264f, 0, 0.5137558015f, 0.7976208196f, -0.3160000073f, 0,
        -0.3794024848f, 0.9245608561f, -0.03522751494f, 0, 0.8229248658f, 0.2745365933f, -0.4974176556f, 0, -0.5404114394f, 0.6091141441f, 0.5804613989f, 0, 0.8036581901f, -0.2703029469f, 0.5301601931f, 0, 0.6044318879f, 0.6832968393f, 0.4095943388f, 0, 0.06389988817f, 0.9658208605f, -0.2512108074f, 0, 0.1087113286f, 0.7402471173f, -0.6634877936f, 0, -0.713427712f, -0.6926784018f, 0.1059128479f, 0,
        0.6458897819f, -0.5724548511f, -0.5050958653f, 0, -0.6553931414f, 0.7381471625f, 0.159995615f, 0, 0.3910961323f, 0.9188871375f, -0.05186755998f, 0, -0.4879022471f, -0.5904376907f, 0.6429111375f, 0, 0.6014790094f, 0.7707441366f, -0.2101820095f, 0, -0.5677173047f, 0.7511360995f, 0.3368851762f, 0, 0.7858573506f, 0.226674665f, 0.5753666838f, 0, -0.4520345543f, -0.604222686f, -0.6561857263f, 0,
        0.002272116345f, 0.4132844051f, -0.9105991643f, 0, -0.5815751419f, -0.5162925989f, 0.6286591339f, 0, -0.03703704785f, 0.8273785755f, 0.5604221175f, 0, -0.5119692504f, 0.7953543429f, -0.3244980058f, 0, -0.2682417366f, -0.9572290247f, -0.1084387619f, 0, -0.2322482736f, -0.9679131102f, -0.09594243324f, 0, 0.3554328906f, -0.8881505545f, 0.2913006227f, 0, 0.7346520519f, -0.4371373164f, 0.5188422971f, 0,
        0.9985120116f, 0.04659011161f, -0.02833944577f, 0, -0.3727687496f, -0.9082481361f, 0.1900757285f, 0, 0.91737377f, -0.3483642108f, 0.1925298489f, 0, 0.2714911074f, 0.4147529736f, -0.8684886582f, 0, 0.5131763485f, -0.7116334161f, 0.4798207128f, 0, -0.8737353606f, 0.18886992f, -0.4482350644f, 0, 0.8460043821f, -0.3725217914f, 0.3814499973f, 0, 0.8978727456f, -0.1780209141f, -0.4026575304f, 0,
        0.2178065647f, -0.9698322841f, -0.1094789531f, 0, -0.1518031304f, -0.7788918132f, -0.6085091231f, 0, -0.2600384876f, -0.4755398075f, -0.8403819825f, 0, 0.572313509f, -0.7474340931f, -0.3373418503f, 0, -0.7174141009f, 0.1699017182f, -0.6756111411f, 0, -0.684180784f, 0.02145707593f, -0.7289967412f, 0, -0.2007447902f, 0.06555605789f, -0.9774476623f, 0, -0.1148803697f, -0.8044887315f, 0.5827524187f, 0,
        -0.7870349638f, 0.03447489231f, 0.6159443543f, 0, -0.2015596421f, 0.6859872284f, 0.6991389226f, 0, -0.08581082512f, -0.10920836f, -0.9903080513f, 0, 0.5532693395f, 0.7325250401f, -0.396610771f, 0, -0.1842489331f, -0.9777375055f, -0.1004076743f, 0, 0.0775473789f, -0.9111505856f, 0.4047110257f, 0, 0.1399838409f, 0.7601631212f, -0.6344734459f, 0, 0.4484419361f, -0.845289248f, 0.2904925424f, 0
    ]

    # Hash primes

    PrimeX = 501125321
    PrimeY = 1136930381
    PrimeZ = 1720413743

## Utils

proc fastMin(a, b: float): float =
    if a < b:
        result = a
    else:
        result = b
    
proc fastMax(a, b: float): float =
    if a > b:
        result = a
    else:
        result = b
    
proc fastAbs(a: float): float =
    if a < 0:
        result = -a
    else:
        result = a
    
proc fastSqrt(a: float): float =
    result = sqrt(a)

proc fastFloor(a: float): int =
    if a >= 0:
        result = int(a)
    else:
        result = int(a) - 1
    
proc fastRound(a: float): int =
    if a >= 0:
        result = int(a + 0.5)
    else:
        result = int(a - 0.5)

proc lerp(a, b, t: float): float =
    result = a + t * (b - a)

proc interpHermite(t: float): float =
    result = t * t * (3 - 2 * t)

proc interpQuintic(t: float): float =
    result = t * t * t * (t * (t * 6 - 15) + 10)

proc cubicLerp(a, b, c, d, t: float): float =
    let p = (d - c) - (a - b)
    result = t * t * t * p + t * t * ((a - b) - p) + t * (c - a) + b

proc pingPong(t: var float): float =
    t -= ((t * 0.5).int * 2).float
    if t < 1:
        result = t
    else:
        result = 2 - t
    
proc calculateFractalBounding(fnl: var FnlNoise) =
    let gain = fastAbs(fnl.gain)
    var amp = gain
    var ampFractal = 1.0
    for i in 1 .. fnl.octaves:
        ampFractal += amp
        amp *= gain
    
    fnl.fractalBounding = 1 / ampFractal

proc hash(seed: int, xPrimed: int, yPrimed: int): int =
    var hash = seed
    hash = hash xor xPrimed
    hash = hash xor yPrimed
    
    # overflow stuff
    hash = (hash * 0x27d4eb2d) and 0x7FFFFFFF
    
    result = hash

proc hash(seed: int, xPrimed: int, yPrimed: int, zPrimed: int): int =
    var hash = seed
    hash = hash xor xPrimed
    hash = hash xor yPrimed
    hash = hash xor zPrimed
    
    # overflow stuff
    hash = (hash * 0x27d4eb2d) and 0x7FFFFFFF
    
    result = hash

proc valCoord(seed: int, xPrimed: int, yPrimed: int): float =

    var hash = hash(seed, xPrimed, yPrimed)

    hash *= hash
    hash = (hash ^ hash) shl 19
    var hash2: float = hash.float # wack
    hash2 = hash2 * (1 / 2147483648.0)

    result = hash2

proc valCoord(seed: int, xPrimed: int, yPrimed: int, zPrimed: int): float =

    var hash = hash(seed, xPrimed, yPrimed, zPrimed)

    hash *= hash
    hash = (hash ^ hash) shl 19
    var hash2: float = hash.float
    hash2 = hash2 * (1 / 2147483648.0)

    result = hash2

proc gradCoord(seed: int, xPrimed: int, yPrimed: int, xd: float, yd: float): float =
    var hash = hash(seed, xPrimed, yPrimed)
    hash = (hash xor (hash shr 15)) and 127 # Fix: bitwise AND with 127 instead of shl
    
    let xg = Gradients2D[hash * 2]
    let yg = Gradients2D[hash * 2 + 1]
    
    result = xd * xg + yd * yg

proc gradCoord(seed: int, xPrimed: int, yPrimed: int, zPrimed: int, xd: float, yd: float, zd: float): float =
    var hash = hash(seed, xPrimed, yPrimed, zPrimed)
    hash = (hash xor (hash shr 15)) and 63 # Fix: bitwise AND with 63 instead of shl
    
    let xg = Gradients3D[hash * 4].float
    let yg = Gradients3D[hash * 4 + 1].float
    let zg = Gradients3D[hash * 4 + 2].float
    
    result = xd * xg + yd * yg + zd * zg

proc gradCoordOut(seed: int, xPrimed: int, yPrimed: int, xo: var float, yo: var float): void = 
    var hash = hash(seed, xPrimed, yPrimed) and 255
    
    xo = RandVecs2D[hash * 2]
    yo = RandVecs2D[hash * 2 + 1]

proc gradCoordOut(seed: int, xPrimed: int, yPrimed: int, zPrimed: int, xo: var float, yo: var float, zo: var float): void =
    var hash = hash(seed, xPrimed, yPrimed, zPrimed) and 255
    
    xo = RandVecs3D[hash * 4]
    yo = RandVecs3D[hash * 4 + 1]
    zo = RandVecs3D[hash * 4 + 2]

proc gradCoordDual(seed: int, xPrimed: int, yPrimed: int, xd: float, yd: float, xo: var float, yo: var float): void =
    let hash = hash(seed, xPrimed, yPrimed)
    let index1 = hash and 127
    let index2 = (hash shr 7) and 255
    
    let idx1 = (index1 * 2) and 0xFF
    let idx2 = (index2 * 2) and 0xFF
    
    let xg = Gradients2D[idx1]
    let yg = Gradients2D[idx1 + 1]
    let val = xd * xg + yd * yg
    
    let xgo = RandVecs2D[idx2]
    let ygo = RandVecs2D[idx2 + 1]
    
    xo = val * xgo
    yo = val * ygo

proc gradCoordDual(seed: int, xPrimed: int, yPrimed: int, zPrimed: int, xd: float, yd: float, zd: float, xo: var float, yo: var float, zo: var float): void =
    let hash = hash(seed, xPrimed, yPrimed, zPrimed)
    let index1 = hash and 63
    let index2 = (hash shr 6) and 255
    
    let xg = Gradients3D[index1 * 4].float
    let yg = Gradients3D[index1 * 4 + 1].float
    let zg = Gradients3D[index1 * 4 + 2].float
    let val = xd * xg + yd * yg + zd * zg
    
    let xgo = RandVecs3D[index2 * 4]
    let ygo = RandVecs3D[index2 * 4 + 1]
    let zgo = RandVecs3D[index2 * 4 + 2]
    
    xo = val * xgo
    yo = val * ygo
    zo = val * zgo

## FNL

### generic
### noise coordinate transforms

proc transformNoiseCoordinate(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat): void =

    x *= fnl.frequency
    y *= fnl.frequency

    case fnl.noiseType:
        of FnlNoiseType.OpenSimplex2, FnlNoiseType.OpenSimplex2S:
            const 
                SQRT3: FnlFloat = 1.7320508075688772935274463415059
                F2: FnlFloat = 0.5 * (SQRT3 - 1)
            let t = (x + y) * F2
            x += t
            y += t  
        else:
            discard

proc transformNoiseCoordinate(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): void =

    x *= fnl.frequency
    y *= fnl.frequency
    z *= fnl.frequency

    case fnl.transformType:
        of FnlTransformType.ImproveXYPlanes:
            let xy = x + y
            let s2 = xy * - FnlFloat(0.211324865405187)
            x += s2 - z
            y = y + s2 - z
            z += xy * FnlFloat(0.577350269189626)
        
        of FnlTransformType.ImproveXZPlanes:
            let xz = x + z
            let s2 = xz * - FnlFloat(0.211324865405187)
            y *= FnlFloat(0.577350269189626)
            x += s2 - y
            z += s2 - y
            y += xz * FnlFloat(0.577350269189626)
        of FnlTransformType.DefaultOpenSimplex2:
            const 
                R3: FnlFloat = FnlFloat(2.0 / 3.0)
            let r = (x + y + z) * R3
            x = r - x
            y = r - y
            z = r - z
        else:
            discard

proc updateTransformType(fnl: var FnlNoise) =
    case fnl.rotationType:
        of FnlRotationType.ImproveXYPlanes:
            fnl.transformType = FnlTransformType.ImproveXYPlanes
        of FnlRotationType.ImproveXZPlanes:
            fnl.transformType = FnlTransformType.ImproveXZPlanes
        else:
            case fnl.noiseType:
                of FnlNoiseType.OpenSimplex2, FnlNoiseType.OpenSimplex2S:
                    fnl.transformType = FnlTransformType.DefaultOpenSimplex2
                else:
                    fnl.transformType = FnlTransformType.None

### domain warp coordinate transforms

proc transformDomainWarpCoordinate(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat): void =
    case fnl.domainWarpType:
        of FnlDomainWarpType.OpenSimplex2:
            const 
                SQRT3: FnlFloat = 1.7320508075688772935274463415059
                F2: FnlFloat = 0.5 * (SQRT3 - 1)
            let t = (x + y) * F2
            x += t
            y += t
        else:
            discard

proc transformDomainWarpCoordinate(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): void =
    case fnl.transformType:
        of FnlTransformType.ImproveXYPlanes:
            let xy = x + y
            let s2 = xy * - FnlFloat(0.211324865405187)
            x += s2 - z
            y = y + s2 - z
            z += xy * FnlFloat(0.577350269189626)
        
        of FnlTransformType.ImproveXZPlanes:
            let xz = x + z
            let s2 = xz * - FnlFloat(0.211324865405187)
            y *= FnlFloat(0.577350269189626)
            x += s2 - y
            z += s2 - y
            y += xz * FnlFloat(0.577350269189626)
        
        of FnlTransformType.DefaultOpenSimplex2:
            const 
                R3: FnlFloat = FnlFloat(2.0 / 3.0)
            let r = (x + y + z) * R3
            x = r - x
            y = r - y
            z = r - z
        else:
            discard

proc updateWarpTransformType3D(fnl: var FnlNoise): void =
    case fnl.rotationType:
        of FnlRotationType.ImproveXYPlanes:
            fnl.warpTransformType = FnlTransformType.ImproveXYPlanes
        of FnlRotationType.ImproveXZPlanes:
            fnl.warpTransformType = FnlTransformType.ImproveXZPlanes
        else:
            case fnl.noiseType:
                of FnlNoiseType.OpenSimplex2, FnlNoiseType.OpenSimplex2S:
                    fnl.warpTransformType = FnlTransformType.DefaultOpenSimplex2
                else:
                    fnl.warpTransformType = FnlTransformType.None


### simplex/opensimplex2 noises

proc singleSimplex(fnl: FnlNoise, seed: int, x: var FnlFloat, y: var FnlFloat): float =

    const
        SQRT3 = 1.7320508075688772935274463415059
        G2 = (3.0 - SQRT3) / 6.0
    
    var
        i = fastFloor(x)
        j = fastFloor(y)
        xi = float(x - i.float)
        yi = float(y - j.float)

    var t = (xi + yi) * G2
    var x0 = xi - t
    var y0 = yi - t

    i = i * PrimeX
    j = j * PrimeY

    var n0, n1, n2: float

    var a = 0.5 - x0 * x0 - y0 * y0
    if a <= 0:
        n0 = 0.0
    else:
        n0 = (a * a) * (a * a) * gradCoord(seed, i, j, x0, y0)
    
    var c = (
        2 * (1 - 2 * G2) * (1 / G2 - 2) * t +
        (-2 * (1 - 2 * G2) * (1 - 2 * G2)) + a
    )
    if c <= 0:
        n2 = 0.0
    else:
        let x2 = x0 + (2 * G2 - 1)
        let y2 = y0 + (2 * G2 - 1)
        n2 = (c * c) * (c * c) * gradCoord(seed, i, j, x2, y2)
    
    if y0 > x0:
        let x1 = x0 + G2
        let y1 = y0 + (G2 - 1)
        let b = 0.5 - x1 * x1 - y1 * y1
        if b <= 0:
            n1 = 0.0
        else:
            n1 = (b * b) * (b * b) * gradCoord(seed, i, j + PrimeY, x1, y1)
    else:
        let x1 = x0 + (G2 - 1)
        let y1 = y0 + G2
        let b = 0.5 - x1 * x1 - y1 * y1
        if b <= 0:
            n1 = 0.0
        else:
            n1 = (b * b) * (b * b) * gradCoord(seed, i + PrimeX, j, x1, y1)

    var final = (n0 + n1 + n2) * 99.83685446303647
    result = final

proc singleOpenSimplex2(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): float =

    var i = fastRound(x)
    var j = fastRound(y)
    var k = fastRound(z)
    var x0 = x - i.float
    var y0 = y - j.float
    var z0 = z - k.float

    var xNsign = (-1.0 - x0).int or 1
    var yNsign = (-1.0 - y0).int or 1
    var zNsign = (-1.0 - z0).int or 1

    var ax0 = xNsign.float * -x0
    var ay0 = yNsign.float * -y0
    var az0 = zNsign.float * -z0

    i = i * PrimeX
    j = j * PrimeY
    k = k * PrimeZ

    var value = 0.0
    var a = (0.6 - x0 * x0) - (y0 * y0 + z0 * z0)

    var l = 0
    while true:
        if a > 0:
            value += (a * a) * (a * a) * gradCoord(seed, i, j, k, x0, y0, z0)

        if ax0 >= ay0 and ax0 >= az0:
            var b = a + ax0 + ax0
            if b > 1:
                b -= 1
                value += (b * b) * (b * b) * gradCoord(seed, i - xNsign * PrimeX, j, k, x0 + xNsign.float, y0, z0)
        elif ay0 > ax0 and ay0 >= az0:
            var b = a + ay0 + ay0
            if b > 1:
                b -= 1
                value += (b * b) * (b * b) * gradCoord(seed, i, j - yNsign * PrimeY, k, x0, y0 + yNsign.float, z0)
        else:
            var b = a + az0 + az0 
            if b > 1:
                b -= 1
                value += (b * b) * (b * b) * gradCoord(seed, i, j, k - zNsign * PrimeZ, x0, y0, z0 + zNsign.float)
        
        if l == 1:
            break
        
        ax0 = 0.5 - ax0
        ay0 = 0.5 - ay0
        az0 = 0.5 - az0

        x0 = xNSign.float * ax0
        y0 = yNSign.float * ay0
        z0 = zNSign.float * az0

        a += (0.75 - ax0) - (ay0 + az0)

        i += (xNSign shr 1) and (PrimeX and 0x7FFFFFFF)
        j += (yNSign shr 1) and (PrimeY and 0x7FFFFFFF)
        k += (zNSign shr 1) and (PrimeZ and 0x7FFFFFFF)

        xNSign = -xNSign
        yNSign = -yNSign
        zNSign = -zNSign

        seed = not(seed)

        l += 1

    result = value * 32.69428253173828125

### open simplex2s
### writing this much noise code makes me want to die
### i know its just conversion but stilllll

proc singleOpenSimplex2S(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat): float =

    const
        SQRT3: FnlFloat = 1.7320508075688772935274463415059
        G2: FnlFloat = (3.0 - SQRT3) / 6.0
    
    var i = fastFloor(x)
    var j = fastFloor(y)
    var xi = x - i.float
    var yi = y - j.float

    i *= PrimeX
    j *= PrimeY
    var i1 = i + PrimeX
    var j1 = j + PrimeY

    var t = (xi + yi) * G2
    var x0 = xi - t
    var y0 = yi - t

    var a0 = (2.0 / 3.0) - x0 * x0 - y0 * y0
    var value = (a0 * a0) * (a0 * a0) * gradCoord(seed, i, j, x0, y0)

    var a1 = (2 * (1 - 2 * G2) * (1 / G2 - 2) * t + (-2 * (1 - 2 * G2) * (1 - 2 * G2)) + a0)
    var x1 = x0 - (1 - 2 * G2)
    var y1 = y0 - (1 - 2 * G2)
    value += (a1 * a1) * (a1 * a1) * gradCoord(seed, i1, j1, x1, y1)

    var xmyi = xi - yi

    if t > G2:
        if xi + xmyi > 1:
            var x2 = x0 + (3 * G2 - 2)
            var y2 = y0 + (3 * G2 - 1)
            var a2 = (2.0 / 3.0) - x2 * x2 - y2 * y2
            if a2 > 0:
                value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i + (PrimeX shl 1), j + PrimeY, x2, y2)
        
        else:
            var x2 = x0 + G2
            var y2 = y0 + (G2 - 1)
            var a2 = (2.0 / 3.0) - x2 * x2 - y2 * y2
            if a2 > 0:
                value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i, j + PrimeY, x2, y2)

        if yi - xmyi > 1:
            var x3 = x0 + (G2 - 1)
            var y3 = y0 + (G2 - 2)
            var a3 = (2.0 / 3.0) - x3 * x3 - y3 * y3
            if a3 > 0:
                value += (a3 * a3) * (a3 * a3) * gradCoord(seed, i + PrimeX, j + (PrimeY shl 1), x3, y3)
        else:
            var x3 = x0 + (G2 - 1)
            var y3 = y0 + G2
            var a3 = (2.0 / 3.0) - x3 * x3 - y3 * y3
            if a3 > 0:
                value += (a3 * a3) * (a3 * a3) * gradCoord(seed, i + PrimeX, j, x3, y3)
    else:

        if xi + xmyi < 0:
            var x2 = x0 + (1 - G2)
            var y2 = y0 + (2 - G2)
            var a2 = (2.0 / 3.0) - x2 * x2 - y2 * y2
            if a2 > 0:
                value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i - PrimeX, j, x2, y2)
        else:
            var x2 = x0 - G2
            var y2 = y0 + G2
            var a2 = (2.0 / 3.0) - x2 * x2 - y2 * y2
            if a2 > 0:
                value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i + PrimeX, j, x2, y2)

        if yi < xmyi:
            var x2 = x0 - G2
            var y2 = y0 + G2
            var a2 = (2.0 / 3.0) - x2 * x2 - y2 * y2
            if a2 > 0:
                value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i, j - PrimeY, x2, y2)
        else:
            var x2 = x0 + G2
            var y2 = y0 - G2
            var a2 = (2.0 / 3.0) - x2 * x2 - y2 * y2
            if a2 > 0:
                value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i, j + PrimeY, x2, y2)

    result = value * 32.69428253173828125

proc singleOpenSimplex2S(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): float =
    var i = fastFloor(x)
    var j = fastFloor(y)
    var k = fastFloor(z)
    let xi = float(x - i.float)
    let yi = float(y - j.float)
    let zi = float(z - k.float)

    i *= PrimeX
    j *= PrimeY
    k *= PrimeZ
    var seed2 = seed + 1293373

    let xNMask = (-0.5 - xi).int
    let yNMask = (-0.5 - yi).int
    let zNMask = (-0.5 - zi).int

    let x0 = xi + xNMask.float
    let y0 = yi + yNMask.float
    let z0 = zi + zNMask.float
    let a0 = 0.75 - x0 * x0 - y0 * y0 - z0 * z0
    var value = (a0 * a0) * (a0 * a0) * gradCoord(seed,
        i + (xNMask and PrimeX), j + (yNMask and PrimeY), k + (zNMask and PrimeZ), x0, y0, z0)

    let x1 = xi - 0.5
    let y1 = yi - 0.5
    let z1 = zi - 0.5
    let a1 = 0.75 - x1 * x1 - y1 * y1 - z1 * z1
    value += (a1 * a1) * (a1 * a1) * gradCoord(seed2,
        i + PrimeX, j + PrimeY, k + PrimeZ, x1, y1, z1)

    let xAFlipMask0 = ((xNMask or 1) shl 1).float * x1
    let yAFlipMask0 = ((yNMask or 1) shl 1).float * y1
    let zAFlipMask0 = ((zNMask or 1) shl 1).float * z1
    let xAFlipMask1 = (-2 - (xNMask shl 2)).float * x1 - 1.0
    let yAFlipMask1 = (-2 - (yNMask shl 2)).float * y1 - 1.0
    let zAFlipMask1 = (-2 - (zNMask shl 2)).float * z1 - 1.0

    var skip5 = false
    let a2 = xAFlipMask0 + a0
    if a2 > 0:
        let x2 = x0 - (xNMask or 1).float
        let y2 = y0
        let z2 = z0
        value += (a2 * a2) * (a2 * a2) * gradCoord(seed,
            i + (not xNMask and PrimeX), j + (yNMask and PrimeY), k + (zNMask and PrimeZ), x2, y2, z2)
    else:
        let a3 = yAFlipMask0 + zAFlipMask0 + a0
        if a3 > 0:
            let x3 = x0
            let y3 = y0 - (yNMask or 1).float
            let z3 = z0 - (zNMask or 1).float
            value += (a3 * a3) * (a3 * a3) * gradCoord(seed,
                i + (xNMask and PrimeX), j + (not yNMask and PrimeY), k + (not zNMask and PrimeZ), x3, y3, z3)

        let a4 = xAFlipMask1 + a1
        if a4 > 0:
            let x4 = (xNMask or 1).float + x1
            let y4 = y1
            let z4 = z1
            value += (a4 * a4) * (a4 * a4) * gradCoord(seed2,
                i + (xNMask and (PrimeX * 2)), j + PrimeY, k + PrimeZ, x4, y4, z4)
            skip5 = true

    var skip9 = false
    let a6 = yAFlipMask0 + a0
    if a6 > 0:
        let x6 = x0
        let y6 = y0 - (yNMask or 1).float
        let z6 = z0
        value += (a6 * a6) * (a6 * a6) * gradCoord(seed,
            i + (xNMask and PrimeX), j + (not yNMask and PrimeY), k + (zNMask and PrimeZ), x6, y6, z6)
    else:
        let a7 = xAFlipMask0 + zAFlipMask0 + a0
        if a7 > 0:
            let x7 = x0 - (xNMask or 1).float
            let y7 = y0
            let z7 = z0 - (zNMask or 1).float
            value += (a7 * a7) * (a7 * a7) * gradCoord(seed,
                i + (not xNMask and PrimeX), j + (yNMask and PrimeY), k + (not zNMask and PrimeZ), x7, y7, z7)

        let a8 = yAFlipMask1 + a1
        if a8 > 0:
            let x8 = x1
            let y8 = (yNMask or 1).float + y1
            let z8 = z1
            value += (a8 * a8) * (a8 * a8) * gradCoord(seed2,
                i + PrimeX, j + (yNMask and (PrimeY shl 1)), k + PrimeZ, x8, y8, z8)
            skip9 = true

    var skipD = false
    let aA = zAFlipMask0 + a0
    if aA > 0:
        let xA = x0
        let yA = y0
        let zA = z0 - (zNMask or 1).float
        value += (aA * aA) * (aA * aA) * gradCoord(seed,
            i + (xNMask and PrimeX), j + (yNMask and PrimeY), k + (not zNMask and PrimeZ), xA, yA, zA)
    else:
        let aB = xAFlipMask0 + yAFlipMask0 + a0
        if aB > 0:
            let xB = x0 - (xNMask or 1).float
            let yB = y0 - (yNMask or 1).float
            let zB = z0
            value += (aB * aB) * (aB * aB) * gradCoord(seed,
                i + (not xNMask and PrimeX), j + (not yNMask and PrimeY), k + (zNMask and PrimeZ), xB, yB, zB)

        let aC = zAFlipMask1 + a1
        if aC > 0:
            let xC = x1
            let yC = y1
            let zC = (zNMask or 1).float + z1
            value += (aC * aC) * (aC * aC) * gradCoord(seed2,
                i + PrimeX, j + PrimeY, k + (zNMask and (PrimeZ shl 1)), xC, yC, zC)
            skipD = true

    if not skip5:
        let a5 = yAFlipMask1 + zAFlipMask1 + a1
        if a5 > 0:
            let x5 = x1
            let y5 = (yNMask or 1).float + y1
            let z5 = (zNMask or 1).float + z1
            value += (a5 * a5) * (a5 * a5) * gradCoord(seed2,
                i + PrimeX, j + (yNMask and (PrimeY shl 1)), k + (zNMask and (PrimeZ shl 1)), x5, y5, z5)

    if not skip9:
        let a9 = xAFlipMask1 + zAFlipMask1 + a1
        if a9 > 0:
            let x9 = (xNMask or 1).float + x1
            let y9 = y1
            let z9 = (zNMask or 1).float + z1
            value += (a9 * a9) * (a9 * a9) * gradCoord(seed2,
                i + (xNMask and (PrimeX * 2)), j + PrimeY, k + (zNMask and (PrimeZ shl 1)), x9, y9, z9)

    if not skipD:
        let aD = xAFlipMask1 + yAFlipMask1 + a1
        if aD > 0:
            let xD = (xNMask or 1).float + x1
            let yD = (yNMask or 1).float + y1
            let zD = z1
            value += (aD * aD) * (aD * aD) * gradCoord(seed2,
                i + (xNMask and (PrimeX shl 1)), j + (yNMask and (PrimeY shl 1)), k + PrimeZ, xD, yD, zD)

    result = value * 9.046026385208288

proc singleCellular(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat): float =
    var xr = fastRound(x)
    var yr = fastRound(y)

    var distance0 = high(float)
    var distance1 = high(float)
    var closestHash = 0

    let cellularJitter = 0.43701595 * fnl.cellularJitterModifier

    var xPrimed = (xr - 1) * PrimeX
    var yPrimedBase = (yr - 1) * PrimeY

    case fnl.cellularDistanceFunction:
        of FnlCellularDistanceFunction.Euclidean, FnlCellularDistanceFunction.EuclideanSq:
            for xi in xr-1 .. xr+1:
                var yPrimed = yPrimedBase

                for yi in yr-1 .. yr+1:
                    let hash = hash(seed, xPrimed, yPrimed)
                    let idx = hash and (255 shl 1)

                    let vecX = (xi.float - x).float + RandVecs2D[idx] * cellularJitter
                    let vecY = (yi.float - y).float + RandVecs2D[idx or 1] * cellularJitter

                    let newDistance = vecX * vecX + vecY * vecY

                    distance1 = fastMax(fastMin(distance1, newDistance), distance0)
                    if newDistance < distance0:
                        distance0 = newDistance
                        closestHash = hash
                    yPrimed += PrimeY
                xPrimed += PrimeX
        
        of FnlCellularDistanceFunction.Manhattan:
            for xi in xr-1 .. xr+1:
                var yPrimed = yPrimedBase

                for yi in yr-1 .. yr+1:
                    let hash = hash(seed, xPrimed, yPrimed)
                    let idx = hash and (255 shl 1)

                    let vecX = (xi.float - x).float + RandVecs2D[idx] * cellularJitter
                    let vecY = (yi.float - y).float + RandVecs2D[idx or 1] * cellularJitter

                    let newDistance = fastAbs(vecX) + fastAbs(vecY)

                    distance1 = fastMax(fastMin(distance1, newDistance), distance0)
                    if newDistance < distance0:
                        distance0 = newDistance
                        closestHash = hash
                    yPrimed += PrimeY
                xPrimed += PrimeX
        
        of FnlCellularDistanceFunction.Hybrid:
            for xi in xr-1 .. xr+1:
                var yPrimed = yPrimedBase

                for yi in yr-1 .. yr+1:
                    let hash = hash(seed, xPrimed, yPrimed)
                    let idx = hash and (255 shl 1)

                    let vecX = (xi.float - x).float + RandVecs2D[idx] * cellularJitter
                    let vecY = (yi.float - y).float + RandVecs2D[idx or 1] * cellularJitter

                    let newDistance = (fastAbs(vecX) + fastAbs(vecY)) + (vecX * vecX + vecY * vecY)

                    distance1 = fastMax(fastMin(distance1, newDistance), distance0)
                    if newDistance < distance0:
                        distance0 = newDistance
                        closestHash = hash
                    yPrimed += PrimeY
                xPrimed += PrimeX

    if fnl.cellularDistanceFunction == FnlCellularDistanceFunction.Euclidean and 
       fnl.cellularReturnType >= FnlCellularReturnType.Distance:
        distance0 = fastSqrt(distance0)

        if fnl.cellularReturnType >= FnlCellularReturnType.Distance2:
            distance1 = fastSqrt(distance1)

    case fnl.cellularReturnType:
        of FnlCellularReturnType.CellValue:
            result = closestHash.float * (1.0 / 2147483648.0)
        of FnlCellularReturnType.Distance:
            result = distance0 - 1.0
        of FnlCellularReturnType.Distance2:
            result = distance1 - 1.0
        of FnlCellularReturnType.Distance2Add:
            result = (distance1 + distance0) * 0.5 - 1.0
        of FnlCellularReturnType.Distance2Sub:
            result = distance1 - distance0 - 1.0
        of FnlCellularReturnType.Distance2Mul:
            result = distance1 * distance0 * 0.5 - 1.0
        of FnlCellularReturnType.Distance2Div:
            result = distance0 / distance1 - 1.0

proc singleCellular(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): float =
    var xr = fastRound(x)
    var yr = fastRound(y)
    var zr = fastRound(z)

    var distance0 = high(float)
    var distance1 = high(float)
    var closestHash = 0

    let cellularJitter = 0.39614353 * fnl.cellularJitterModifier

    var xPrimed = (xr - 1) * PrimeX
    var yPrimedBase = (yr - 1) * PrimeY
    var zPrimedBase = (zr - 1) * PrimeZ

    case fnl.cellularDistanceFunction:
        of FnlCellularDistanceFunction.Euclidean, FnlCellularDistanceFunction.EuclideanSq:
            for xi in xr-1 .. xr+1:
                var yPrimed = yPrimedBase

                for yi in yr-1 .. yr+1:
                    var zPrimed = zPrimedBase

                    for zi in zr-1 .. zr+1:
                        let hash = hash(seed, xPrimed, yPrimed, zPrimed)
                        let idx = hash and (255 shl 2)

                        let vecX = (xi.float - x).float + RandVecs3D[idx] * cellularJitter
                        let vecY = (yi.float - y).float + RandVecs3D[idx or 1] * cellularJitter
                        let vecZ = (zi.float - z).float + RandVecs3D[idx or 2] * cellularJitter

                        let newDistance = vecX * vecX + vecY * vecY + vecZ * vecZ

                        distance1 = fastMax(fastMin(distance1, newDistance), distance0)
                        if newDistance < distance0:
                            distance0 = newDistance
                            closestHash = hash
                        zPrimed += PrimeZ
                    yPrimed += PrimeY
                xPrimed += PrimeX
        
        of FnlCellularDistanceFunction.Manhattan:
            for xi in xr-1 .. xr+1:
                var yPrimed = yPrimedBase

                for yi in yr-1 .. yr+1:
                    var zPrimed = zPrimedBase

                    for zi in zr-1 .. zr+1:
                        let hash = hash(seed, xPrimed, yPrimed, zPrimed)
                        let idx = hash and (255 shl 2)

                        let vecX = (xi.float - x).float + RandVecs3D[idx] * cellularJitter
                        let vecY = (yi.float - y).float + RandVecs3D[idx or 1] * cellularJitter
                        let vecZ = (zi.float - z).float + RandVecs3D[idx or 2] * cellularJitter

                        let newDistance = fastAbs(vecX) + fastAbs(vecY) + fastAbs(vecZ)

                        distance1 = fastMax(fastMin(distance1, newDistance), distance0)
                        if newDistance < distance0:
                            distance0 = newDistance
                            closestHash = hash
                        zPrimed += PrimeZ
                    yPrimed += PrimeY
                xPrimed += PrimeX
        
        of FnlCellularDistanceFunction.Hybrid:
            for xi in xr-1 .. xr+1:
                var yPrimed = yPrimedBase

                for yi in yr-1 .. yr+1:
                    var zPrimed = zPrimedBase

                    for zi in zr-1 .. zr+1:
                        let hash = hash(seed, xPrimed, yPrimed, zPrimed)
                        let idx = hash and (255 shl 2)

                        let vecX = (xi.float - x).float + RandVecs3D[idx] * cellularJitter
                        let vecY = (yi.float - y).float + RandVecs3D[idx or 1] * cellularJitter
                        let vecZ = (zi.float - z).float + RandVecs3D[idx or 2] * cellularJitter

                        let newDistance = (fastAbs(vecX) + fastAbs(vecY) + fastAbs(vecZ)) + 
                                          (vecX * vecX + vecY * vecY + vecZ * vecZ)

                        distance1 = fastMax(fastMin(distance1, newDistance), distance0)
                        if newDistance < distance0:
                            distance0 = newDistance
                            closestHash = hash
                        zPrimed += PrimeZ
                    yPrimed += PrimeY
                xPrimed += PrimeX

    if fnl.cellularDistanceFunction == FnlCellularDistanceFunction.Euclidean and 
       fnl.cellularReturnType >= FnlCellularReturnType.Distance:
        distance0 = fastSqrt(distance0)

        if fnl.cellularReturnType >= FnlCellularReturnType.Distance2:
            distance1 = fastSqrt(distance1)

    case fnl.cellularReturnType:
        of FnlCellularReturnType.CellValue:
            result = closestHash.float * (1.0 / 2147483648.0)
        of FnlCellularReturnType.Distance:
            result = distance0 - 1.0
        of FnlCellularReturnType.Distance2:
            result = distance1 - 1.0
        of FnlCellularReturnType.Distance2Add:
            result = (distance1 + distance0) * 0.5 - 1.0
        of FnlCellularReturnType.Distance2Sub:
            result = distance1 - distance0 - 1.0
        of FnlCellularReturnType.Distance2Mul:
            result = distance1 * distance0 * 0.5 - 1.0
        of FnlCellularReturnType.Distance2Div:
            result = distance0 / distance1 - 1.0

proc singlePerlin(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat): float =
    let x0 = fastFloor(x)
    let y0 = fastFloor(y)

    let xd0 = (x - x0.float).float
    let yd0 = (y - y0.float).float
    let xd1 = xd0 - 1.0
    let yd1 = yd0 - 1.0

    let xs = interpQuintic(xd0)
    let ys = interpQuintic(yd0)

    let x0p = x0 * PrimeX
    let y0p = y0 * PrimeY
    let x1p = x0p + PrimeX
    let y1p = y0p + PrimeY

    let xf0 = lerp(gradCoord(seed, x0p, y0p, xd0, yd0), gradCoord(seed, x1p, y0p, xd1, yd0), xs)
    let xf1 = lerp(gradCoord(seed, x0p, y1p, xd0, yd1), gradCoord(seed, x1p, y1p, xd1, yd1), xs)

    result = lerp(xf0, xf1, ys) * 1.4247691104677813

proc singlePerlin(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): float =
    let x0 = fastFloor(x)
    let y0 = fastFloor(y)
    let z0 = fastFloor(z)

    let xd0 = (x - x0.float).float
    let yd0 = (y - y0.float).float
    let zd0 = (z - z0.float).float
    let xd1 = xd0 - 1.0
    let yd1 = yd0 - 1.0
    let zd1 = zd0 - 1.0

    let xs = interpQuintic(xd0)
    let ys = interpQuintic(yd0)
    let zs = interpQuintic(zd0)

    let x0p = x0 * PrimeX
    let y0p = y0 * PrimeY
    let z0p = z0 * PrimeZ
    let x1p = x0p + PrimeX
    let y1p = y0p + PrimeY
    let z1p = z0p + PrimeZ

    let xf00 = lerp(gradCoord(seed, x0p, y0p, z0p, xd0, yd0, zd0), 
                     gradCoord(seed, x1p, y0p, z0p, xd1, yd0, zd0), xs)
    let xf10 = lerp(gradCoord(seed, x0p, y1p, z0p, xd0, yd1, zd0), 
                     gradCoord(seed, x1p, y1p, z0p, xd1, yd1, zd0), xs)
    let xf01 = lerp(gradCoord(seed, x0p, y0p, z1p, xd0, yd0, zd1), 
                     gradCoord(seed, x1p, y0p, z1p, xd1, yd0, zd1), xs)
    let xf11 = lerp(gradCoord(seed, x0p, y1p, z1p, xd0, yd1, zd1), 
                     gradCoord(seed, x1p, y1p, z1p, xd1, yd1, zd1), xs)

    let yf0 = lerp(xf00, xf10, ys)
    let yf1 = lerp(xf01, xf11, ys)

    result = lerp(yf0, yf1, zs) * 0.964921414852142333984375

### value cubic

proc singleValueCubic(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat): float =
    let x1 = fastFloor(x)
    let y1 = fastFloor(y)

    let xs = (x - x1.float).float
    let ys = (y - y1.float).float

    let x1p = x1 * PrimeX
    let y1p = y1 * PrimeY
    let x0p = x1p - PrimeX
    let y0p = y1p - PrimeY
    let x2p = x1p + PrimeX
    let y2p = y1p + PrimeY
    let x3p = x1p + PrimeX * 2
    let y3p = y1p + PrimeY * 2

    result = cubicLerp(
        cubicLerp(valCoord(seed, x0p, y0p), valCoord(seed, x1p, y0p), valCoord(seed, x2p, y0p), valCoord(seed, x3p, y0p), xs),
        cubicLerp(valCoord(seed, x0p, y1p), valCoord(seed, x1p, y1p), valCoord(seed, x2p, y1p), valCoord(seed, x3p, y1p), xs),
        cubicLerp(valCoord(seed, x0p, y2p), valCoord(seed, x1p, y2p), valCoord(seed, x2p, y2p), valCoord(seed, x3p, y2p), xs),
        cubicLerp(valCoord(seed, x0p, y3p), valCoord(seed, x1p, y3p), valCoord(seed, x2p, y3p), valCoord(seed, x3p, y3p), xs),
        ys) * (1.0 / (1.5 * 1.5))


proc singleValueCubic(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): float =
    let x1 = fastFloor(x)
    let y1 = fastFloor(y)
    let z1 = fastFloor(z)

    let xs = (x - x1.float).float
    let ys = (y - y1.float).float
    let zs = (z - z1.float).float

    let x1p = x1 * PrimeX
    let y1p = y1 * PrimeY
    let z1p = z1 * PrimeZ

    let x0p = x1p - PrimeX
    let y0p = y1p - PrimeY
    let z0p = z1p - PrimeZ
    let x2p = x1p + PrimeX
    let y2p = y1p + PrimeY
    let z2p = z1p + PrimeZ
    let x3p = x1p + PrimeX * 2
    let y3p = y1p + PrimeY * 2
    let z3p = z1p + PrimeZ * 2

    result = cubicLerp(
        cubicLerp(
            cubicLerp(valCoord(seed, x0p, y0p, z0p), valCoord(seed, x1p, y0p, z0p), valCoord(seed, x2p, y0p, z0p), valCoord(seed, x3p, y0p, z0p), xs),
            cubicLerp(valCoord(seed, x0p, y1p, z0p), valCoord(seed, x1p, y1p, z0p), valCoord(seed, x2p, y1p, z0p), valCoord(seed, x3p, y1p, z0p), xs),
            cubicLerp(valCoord(seed, x0p, y2p, z0p), valCoord(seed, x1p, y2p, z0p), valCoord(seed, x2p, y2p, z0p), valCoord(seed, x3p, y2p, z0p), xs),
            cubicLerp(valCoord(seed, x0p, y3p, z0p), valCoord(seed, x1p, y3p, z0p), valCoord(seed, x2p, y3p, z0p), valCoord(seed, x3p, y3p, z0p), xs),
            ys),
        cubicLerp(
            cubicLerp(valCoord(seed, x0p, y0p, z1p), valCoord(seed, x1p, y0p, z1p), valCoord(seed, x2p, y0p, z1p), valCoord(seed, x3p, y0p, z1p), xs),
            cubicLerp(valCoord(seed, x0p, y1p, z1p), valCoord(seed, x1p, y1p, z1p), valCoord(seed, x2p, y1p, z1p), valCoord(seed, x3p, y1p, z1p), xs),
            cubicLerp(valCoord(seed, x0p, y2p, z1p), valCoord(seed, x1p, y2p, z1p), valCoord(seed, x2p, y2p, z1p), valCoord(seed, x3p, y2p, z1p), xs),
            cubicLerp(valCoord(seed, x0p, y3p, z1p), valCoord(seed, x1p, y3p, z1p), valCoord(seed, x2p, y3p, z1p), valCoord(seed, x3p, y3p, z1p), xs),
            ys),
        cubicLerp(
            cubicLerp(valCoord(seed, x0p, y0p, z2p), valCoord(seed, x1p, y0p, z2p), valCoord(seed, x2p, y0p, z2p), valCoord(seed, x3p, y0p, z2p), xs),
            cubicLerp(valCoord(seed, x0p, y1p, z2p), valCoord(seed, x1p, y1p, z2p), valCoord(seed, x2p, y1p, z2p), valCoord(seed, x3p, y1p, z2p), xs),
            cubicLerp(valCoord(seed, x0p, y2p, z2p), valCoord(seed, x1p, y2p, z2p), valCoord(seed, x2p, y2p, z2p), valCoord(seed, x3p, y2p, z2p), xs),
            cubicLerp(valCoord(seed, x0p, y3p, z2p), valCoord(seed, x1p, y3p, z2p), valCoord(seed, x2p, y3p, z2p), valCoord(seed, x3p, y3p, z2p), xs),
            ys),
        cubicLerp(
            cubicLerp(valCoord(seed, x0p, y0p, z3p), valCoord(seed, x1p, y0p, z3p), valCoord(seed, x2p, y0p, z3p), valCoord(seed, x3p, y0p, z3p), xs),
            cubicLerp(valCoord(seed, x0p, y1p, z3p), valCoord(seed, x1p, y1p, z3p), valCoord(seed, x2p, y1p, z3p), valCoord(seed, x3p, y1p, z3p), xs),
            cubicLerp(valCoord(seed, x0p, y2p, z3p), valCoord(seed, x1p, y2p, z3p), valCoord(seed, x2p, y2p, z3p), valCoord(seed, x3p, y2p, z3p), xs),
            cubicLerp(valCoord(seed, x0p, y3p, z3p), valCoord(seed, x1p, y3p, z3p), valCoord(seed, x2p, y3p, z3p), valCoord(seed, x3p, y3p, z3p), xs),
            ys),
        zs) * (1.0 / (1.5 * 1.5 * 1.5))

### value noise

proc singleValue(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat): float =
    let x0 = fastFloor(x)
    let y0 = fastFloor(y)

    let xs = interpHermite((x - x0.float).float)
    let ys = interpHermite((y - y0.float).float)

    let x0p = x0 * PrimeX
    let y0p = y0 * PrimeY
    let x1p = x0p + PrimeX
    let y1p = y0p + PrimeY

    let xf0 = lerp(valCoord(seed, x0p, y0p), valCoord(seed, x1p, y0p), xs)
    let xf1 = lerp(valCoord(seed, x0p, y1p), valCoord(seed, x1p, y1p), xs)

    result = lerp(xf0, xf1, ys)

proc singleValue(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): float =
    let x0 = fastFloor(x)
    let y0 = fastFloor(y)
    let z0 = fastFloor(z)

    let xs = interpHermite((x - x0.float).float)
    let ys = interpHermite((y - y0.float).float)
    let zs = interpHermite((z - z0.float).float)

    let x0p = x0 * PrimeX
    let y0p = y0 * PrimeY
    let z0p = z0 * PrimeZ
    let x1p = x0p + PrimeX
    let y1p = y0p + PrimeY
    let z1p = z0p + PrimeZ

    let xf00 = lerp(valCoord(seed, x0p, y0p, z0p), valCoord(seed, x1p, y0p, z0p), xs)
    let xf10 = lerp(valCoord(seed, x0p, y1p, z0p), valCoord(seed, x1p, y1p, z0p), xs)
    let xf01 = lerp(valCoord(seed, x0p, y0p, z1p), valCoord(seed, x1p, y0p, z1p), xs)
    let xf11 = lerp(valCoord(seed, x0p, y1p, z1p), valCoord(seed, x1p, y1p, z1p), xs)

    let yf0 = lerp(xf00, xf10, ys)
    let yf1 = lerp(xf01, xf11, ys)

    result = lerp(yf0, yf1, zs)

### domain warp handler

proc singleDomainWarpSimplexGradient(fnl: FnlNoise, seed: var int, warpAmp: float, frequency: float, x: var FnlFloat, y: var FnlFloat, xr: var FnlFloat, yr: var FnlFloat, outGradOnly: bool): void
proc singleDomainWarpSimplexGradient(fnl: FnlNoise, seed: var int, warpAmp: float, frequency: float, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat, xr: var FnlFloat, yr: var FnlFloat, zr: var FnlFloat, outGradOnly: bool): void

proc domainWarpBasicGrid(fnl: FnlNoise, seed: var int, warpAmp: float, frequency: float, x: FnlFloat, y: FnlFloat, xr: var FnlFloat, yr: var FnlFloat): void
proc domainWarpBasicGrid(fnl: FnlNoise, seed: var int, warpAmp: float, frequency: float, x: FnlFloat, y: FnlFloat, z: FnlFloat, xr: var FnlFloat, yr: var FnlFloat, zr: var FnlFloat): void

proc doSingleDomainWarp(fnl: FnlNoise, seed: var int, amp: float, freq: float, x: var FnlFloat, y: var FnlFloat, xr: var FnlFloat, yr: var FnlFloat): void =
    case fnl.domainWarpType:
        of FnlDomainWarpType.OpenSimplex2:
            singleDomainWarpSimplexGradient(fnl, seed, amp * 38.283687591552734375, freq, x, y, xr, yr, false)
        of FnlDomainWarpType.OpenSimplex2Reduced:
            singleDomainWarpSimplexGradient(fnl, seed, amp * 16.0, freq, x, y, xr, yr, true)
        of FnlDomainWarpType.BasicGrid:
            domainWarpBasicGrid(fnl, seed, amp, freq, x, y, xr, yr)

proc doSingleDomainWarp(fnl: FnlNoise, seed: var int, amp: float, freq: float, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat, xr: var FnlFloat, yr: var FnlFloat, zr: var FnlFloat): void =
    case fnl.domainWarpType:
        of FnlDomainWarpType.OpenSimplex2:
            singleDomainWarpSimplexGradient(fnl, seed, amp * 32.69428253173828125, freq, x, y, z, xr, yr, zr, false)
        of FnlDomainWarpType.OpenSimplex2Reduced:
            singleDomainWarpSimplexGradient(fnl, seed, amp * 7.71604938271605, freq, x, y, z, xr, yr, zr, true)
        of FnlDomainWarpType.BasicGrid:
            domainWarpBasicGrid(fnl, seed, amp, freq, x, y, z, xr, yr, zr)

### domain warp singles

proc domainWarpSingle(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat): void =
    var seed = fnl.seed
    let amp = fnl.domainWarpAmp * fnl.fractalBounding
    let freq = fnl.frequency
    
    var xs = x
    var ys = y
    transformDomainWarpCoordinate(fnl, xs, ys)
    
    doSingleDomainWarp(fnl, seed, amp, freq, xs, ys, x, y)

proc domainWarpSingle(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): void =
    var seed = fnl.seed
    let amp = fnl.domainWarpAmp * fnl.fractalBounding
    let freq = fnl.frequency
    
    var xs = x
    var ys = y
    var zs = z
    transformDomainWarpCoordinate(fnl, xs, ys, zs)
    
    doSingleDomainWarp(fnl, seed, amp, freq, xs, ys, zs, x, y, z)

### domain warp fractal progressive

proc domainWarpFractalProgressive(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat): void =
    var seed = fnl.seed
    var amp = fnl.domainWarpAmp * fnl.fractalBounding
    var freq = fnl.frequency
    
    for i in 0 ..< fnl.octaves:
        var xs = x
        var ys = y
        transformDomainWarpCoordinate(fnl, xs, ys)
        
        doSingleDomainWarp(fnl, seed, amp, freq, xs, ys, x, y)
        
        seed += 1
        amp *= fnl.gain
        freq *= fnl.lacunarity

proc domainWarpFractalProgressive(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): void =
    var seed = fnl.seed
    var amp = fnl.domainWarpAmp * fnl.fractalBounding
    var freq = fnl.frequency
    
    for i in 0 ..< fnl.octaves:
        var xs = x
        var ys = y
        var zs = z
        transformDomainWarpCoordinate(fnl, xs, ys, zs)
        
        doSingleDomainWarp(fnl, seed, amp, freq, xs, ys, zs, x, y, z)
        
        seed += 1
        amp *= fnl.gain
        freq *= fnl.lacunarity

### domain warp fractal independent

proc domainWarpFractalIndependent(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat): void =
    var xs = x
    var ys = y
    transformDomainWarpCoordinate(fnl, xs, ys)
    
    var seed = fnl.seed
    var amp = fnl.domainWarpAmp * fnl.fractalBounding
    var freq = fnl.frequency
    
    for i in 0 ..< fnl.octaves:
        doSingleDomainWarp(fnl, seed, amp, freq, xs, ys, x, y)
        
        seed += 1
        amp *= fnl.gain
        freq *= fnl.lacunarity

proc domainWarpFractalIndependent(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): void =
    var xs = x
    var ys = y
    var zs = z
    transformDomainWarpCoordinate(fnl, xs, ys, zs)
    
    var seed = fnl.seed
    var amp = fnl.domainWarpAmp * fnl.fractalBounding
    var freq = fnl.frequency
    
    for i in 0 ..< fnl.octaves:
        doSingleDomainWarp(fnl, seed, amp, freq, xs, ys, zs, x, y, z)
        
        seed += 1
        amp *= fnl.gain
        freq *= fnl.lacunarity

### domain warp basic grid

proc domainWarpBasicGrid(fnl: FnlNoise, seed: var int, warpAmp: float, frequency: float, x: FnlFloat, y: FnlFloat, xr: var FnlFloat, yr: var FnlFloat): void = 
    let xf = x * frequency
    let yf = y * frequency
    
    let x0 = fastFloor(xf)
    let y0 = fastFloor(yf)
    
    let xs = interpHermite((xf - x0.float).float)
    let ys = interpHermite((yf - y0.float).float)
    
    let x0p = x0 * PrimeX
    let y0p = y0 * PrimeY
    let x1p = x0p + PrimeX
    let y1p = y0p + PrimeY
    
    var hash0 = hash(seed, x0p, y0p) and 255
    var hash1 = hash(seed, x1p, y0p) and 255
    
    let lx0x = lerp(RandVecs2D[hash0 * 2], RandVecs2D[hash1 * 2], xs)
    let ly0x = lerp(RandVecs2D[hash0 * 2 + 1], RandVecs2D[hash1 * 2 + 1], xs)
    
    hash0 = hash(seed, x0p, y1p) and 255
    hash1 = hash(seed, x1p, y1p) and 255
    
    let lx1x = lerp(RandVecs2D[hash0 * 2], RandVecs2D[hash1 * 2], xs)
    let ly1x = lerp(RandVecs2D[hash0 * 2 + 1], RandVecs2D[hash1 * 2 + 1], xs)
    
    xr += lerp(lx0x, lx1x, ys) * warpAmp
    yr += lerp(ly0x, ly1x, ys) * warpAmp

proc domainWarpBasicGrid(fnl: FnlNoise, seed: var int, warpAmp: float, frequency: float, x: FnlFloat, y: FnlFloat, z: FnlFloat, xr: var FnlFloat, yr: var FnlFloat, zr: var FnlFloat): void = 
    let xf = x * frequency
    let yf = y * frequency
    let zf = z * frequency
    
    let x0 = fastFloor(xf)
    let y0 = fastFloor(yf)
    let z0 = fastFloor(zf)
    
    let xs = interpHermite((xf - x0.float).float)
    let ys = interpHermite((yf - y0.float).float)
    let zs = interpHermite((zf - z0.float).float)
    
    let x0p = x0 * PrimeX
    let y0p = y0 * PrimeY
    let z0p = z0 * PrimeZ
    let x1p = x0p + PrimeX
    let y1p = y0p + PrimeY
    let z1p = z0p + PrimeZ
    
    var hash0 = hash(seed, x0p, y0p, z0p) and 255
    var hash1 = hash(seed, x1p, y0p, z0p) and 255
    
    let lx0x = lerp(RandVecs3D[hash0 * 4], RandVecs3D[hash1 * 4], xs)
    let ly0x = lerp(RandVecs3D[hash0 * 4 + 1], RandVecs3D[hash1 * 4 + 1], xs)
    let lz0x = lerp(RandVecs3D[hash0 * 4 + 2], RandVecs3D[hash1 * 4 + 2], xs)
    
    hash0 = hash(seed, x0p, y1p, z0p) and 255
    hash1 = hash(seed, x1p, y1p, z0p) and 255
    
    let lx1x = lerp(RandVecs3D[hash0 * 4], RandVecs3D[hash1 * 4], xs)
    let ly1x = lerp(RandVecs3D[hash0 * 4 + 1], RandVecs3D[hash1 * 4 + 1], xs)
    let lz1x = lerp(RandVecs3D[hash0 * 4 + 2], RandVecs3D[hash1 * 4 + 2], xs)
    
    let lx0y = lerp(lx0x, lx1x, ys)
    let ly0y = lerp(ly0x, ly1x, ys)
    let lz0y = lerp(lz0x, lz1x, ys)
    
    hash0 = hash(seed, x0p, y0p, z1p) and (255 shl 2)
    hash1 = hash(seed, x1p, y0p, z1p) and (255 shl 2)
    
    var lx0z = lerp(RandVecs3D[hash0], RandVecs3D[hash1], xs)
    var ly0z = lerp(RandVecs3D[hash0 or 1], RandVecs3D[hash1 or 1], xs)
    var lz0z = lerp(RandVecs3D[hash0 or 2], RandVecs3D[hash1 or 2], xs)
    
    hash0 = hash(seed, x0p, y1p, z1p) and (255 shl 2)
    hash1 = hash(seed, x1p, y1p, z1p) and (255 shl 2)
    
    var lx1z = lerp(RandVecs3D[hash0], RandVecs3D[hash1], xs)
    var ly1z = lerp(RandVecs3D[hash0 or 1], RandVecs3D[hash1 or 1], xs)
    var lz1z = lerp(RandVecs3D[hash0 or 2], RandVecs3D[hash1 or 2], xs)
    
    xr += lerp(lx0y, lerp(lx0z, lx1z, ys), zs) * warpAmp
    yr += lerp(ly0y, lerp(ly0z, ly1z, ys), zs) * warpAmp
    zr += lerp(lz0y, lerp(lz0z, lz1z, ys), zs) * warpAmp

### domain warp simplex/os2

proc singleDomainWarpSimplexGradient(fnl: FnlNoise, seed: var int, warpAmp: float, frequency: float, x: var FnlFloat, y: var FnlFloat, xr: var FnlFloat, yr: var FnlFloat, outGradOnly: bool): void =
    const 
        SQRT3 = 1.7320508075688772935274463415059
        G2 = (3.0 - SQRT3) / 6.0
    
    x *= frequency
    y *= frequency
    
    let i = fastFloor(x)
    let j = fastFloor(y)
    let xi = (x - i.float).float
    let yi = (y - j.float).float
    
    let t = (xi + yi) * G2
    let x0 = (xi - t).float
    let y0 = (yi - t).float
    
    let i1 = i * PrimeX
    let j1 = j * PrimeY
    
    var vx, vy: float
    vx = 0
    vy = 0
    
    let a = 0.5 - x0*x0 - y0*y0
    if a > 0:
        let aaaa = (a * a) * (a * a)
        var xo, yo: float
        if outGradOnly:
            gradCoordOut(seed, i1, j1, xo, yo)
        else:
            gradCoordDual(seed, i1, j1, x0, y0, xo, yo)
        vx += aaaa * xo
        vy += aaaa * yo
    
    let c = (2.0 * (1.0 - 2.0 * G2) * (1.0 / G2 - 2.0)) * t + ((-2.0 * (1.0 - 2.0 * G2) * (1.0 - 2.0 * G2)) + a)
    if c > 0:
        let x2 = x0 + (2.0 * G2 - 1.0)
        let y2 = y0 + (2.0 * G2 - 1.0)
        let cccc = (c * c) * (c * c)
        var xo, yo: float
        if outGradOnly:
            gradCoordOut(seed, i1 + PrimeX, j1 + PrimeY, xo, yo)
        else:
            gradCoordDual(seed, i1 + PrimeX, j1 + PrimeY, x2, y2, xo, yo)
        vx += cccc * xo
        vy += cccc * yo
    
    if y0 > x0:
        let x1 = x0 + G2
        let y1 = y0 + (G2 - 1.0)
        let b = 0.5 - x1*x1 - y1*y1
        if b > 0:
            let bbbb = (b * b) * (b * b)
            var xo, yo: float
            if outGradOnly:
                gradCoordOut(seed, i1, j1 + PrimeY, xo, yo)
            else:
                gradCoordDual(seed, i1, j1 + PrimeY, x1, y1, xo, yo)
            vx += bbbb * xo
            vy += bbbb * yo
    else:
        let x1 = x0 + (G2 - 1.0)
        let y1 = y0 + G2
        let b = 0.5 - x1*x1 - y1*y1
        if b > 0:
            let bbbb = (b * b) * (b * b)
            var xo, yo: float
            if outGradOnly:
                gradCoordOut(seed, i1 + PrimeX, j1, xo, yo)
            else:
                gradCoordDual(seed, i1 + PrimeX, j1, x1, y1, xo, yo)
            vx += bbbb * xo
            vy += bbbb * yo
    
    xr += vx * warpAmp
    yr += vy * warpAmp

proc singleDomainWarpSimplexGradient(fnl: FnlNoise, seed: var int, warpAmp: float, frequency: float, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat, xr: var FnlFloat, yr: var FnlFloat, zr: var FnlFloat, outGradOnly: bool): void =
    x *= frequency
    y *= frequency
    z *= frequency
    
    var i = fastRound(x)
    var j = fastRound(y)
    var k = fastRound(z)
    var x0 = x - i.float
    var y0 = y - j.float
    var z0 = z - k.float
    
    var xNSign = (-1.0 - x0).int or 1
    var yNSign = (-1.0 - y0).int or 1
    var zNSign = (-1.0 - z0).int or 1
    
    var ax0 = xNSign.float * -x0
    var ay0 = yNSign.float * -y0
    var az0 = zNSign.float * -z0
    
    let i1 = i * PrimeX
    let j1 = j * PrimeY
    let k1 = k * PrimeZ
    
    var vx, vy, vz: float
    vx = 0
    vy = 0
    vz = 0
    
    var a = (0.6 - x0 * x0) - (y0 * y0 + z0 * z0)
    
    for l in 0 .. 1:
        if a > 0:
            let aaaa = (a * a) * (a * a)
            var xo, yo, zo: float
            if outGradOnly:
                gradCoordOut(seed, i1, j1, k1, xo, yo, zo)
            else:
                gradCoordDual(seed, i1, j1, k1, x0, y0, z0, xo, yo, zo)
            vx += aaaa * xo
            vy += aaaa * yo
            vz += aaaa * zo
        
        var b = a
        var i2 = i1
        var j2 = j1
        var k2 = k1
        var x1 = x0
        var y1 = y0
        var z1 = z0
        
        if ax0 >= ay0 and ax0 >= az0:
            x1 += xNSign.float
            b += ax0 + ax0
            i2 -= xNSign * PrimeX
        elif ay0 > ax0 and ay0 >= az0:
            y1 += yNSign.float
            b += ay0 + ay0
            j2 -= yNSign * PrimeY
        else:
            z1 += zNSign.float
            b += az0 + az0
            k2 -= zNSign * PrimeZ
        
        if b > 1:
            b -= 1
            let bbbb = (b * b) * (b * b)
            var xo, yo, zo: float
            if outGradOnly:
                gradCoordOut(seed, i2, j2, k2, xo, yo, zo)
            else:
                gradCoordDual(seed, i2, j2, k2, x1, y1, z1, xo, yo, zo)
            vx += bbbb * xo
            vy += bbbb * yo
            vz += bbbb * zo
        
        if l == 1:
            break
        
        ax0 = 0.5 - ax0
        ay0 = 0.5 - ay0
        az0 = 0.5 - az0
        
        x0 = xNSign.float * ax0
        y0 = yNSign.float * ay0
        z0 = zNSign.float * az0
        
        a += (0.75 - ax0) - (ay0 + az0)
        
        i += (xNSign shr 1) and PrimeX
        j += (yNSign shr 1) and PrimeY
        k += (zNSign shr 1) and PrimeZ
        
        xNSign = -xNSign
        yNSign = -yNSign
        zNSign = -zNSign
        
        seed += 1293373
    
    xr += vx * warpAmp
    yr += vy * warpAmp
    zr += vz * warpAmp


proc setSeed*(fnl: var FnlNoise, seed: int) =
    ## Set the seed value used for all noise types
    fnl.seed = seed

proc setFrequency*(fnl: var FnlNoise, frequency: float) =
    ## Set the frequency value used for all noise types
    fnl.frequency = frequency

proc setRotationType3D*(fnl: var FnlNoise, rotationType: FnlRotationType) =
    ## Set the rotation type for 3D noise types
    fnl.rotationType = rotationType
    updateTransformType(fnl)
    updateWarpTransformType3D(fnl)

proc setFractalType*(fnl: var FnlNoise, fractalType: FnlFractalType) =
    ## Set the fractal type
    fnl.fractalType = fractalType

proc setOctaves*(fnl: var FnlNoise, octaves: int) =
    ## Set the number of octaves for fractal noise types
    fnl.octaves = octaves
    calculateFractalBounding(fnl)

proc setLacunarity*(fnl: var FnlNoise, lacunarity: float) =
    ## Set the lacunarity value for fractal noise types
    fnl.lacunarity = lacunarity

proc setFractalGain*(fnl: var FnlNoise, gain: float) =
    ## Set the gain value for fractal noise types
    fnl.gain = gain
    calculateFractalBounding(fnl)

proc setFractalWeightedStrength*(fnl: var FnlNoise, weightedStrength: float) =
    ## Set the weighted strength value for fractal noise types
    fnl.weightedStrength = weightedStrength

proc setFractalPingPongStrength*(fnl: var FnlNoise, pingPongStrength: float) =
    ## Set the ping pong strength value for fractal noise types
    fnl.pingPongStrength = pingPongStrength

proc setCellularDistanceFunction*(fnl: var FnlNoise, cellularDistanceFunction: FnlCellularDistanceFunction) =
    ## Set the cellular distance function
    fnl.cellularDistanceFunction = cellularDistanceFunction

proc setCellularDistanceReturnType*(fnl: var FnlNoise, cellularReturnType: FnlCellularReturnType) =
    ## Set the cellular return type
    fnl.cellularReturnType = cellularReturnType

proc setCellularJitterModifier*(fnl: var FnlNoise, cellularJitterModifier: float) =
    ## Set the cellular jitter modifier
    fnl.cellularJitterModifier = cellularJitterModifier

proc setDomainWarpType*(fnl: var FnlNoise, domainWarpType: FnlDomainWarpType) =
    ## Set the domain warp type
    fnl.domainWarpType = domainWarpType
    updateWarpTransformType3D(fnl)

proc setDomainWarpAmp*(fnl: var FnlNoise, domainWarpAmp: float) =
    ## Set the domain warp amplitude
    fnl.domainWarpAmp = domainWarpAmp

proc setNoiseType*(fnl: var FnlNoise, noiseType: FnlNoiseType) =
    ## Set the noise type
    fnl.noiseType = noiseType
    updateTransformType(fnl)

proc genNoiseSingle(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat): float =
    case fnl.noiseType
        of FnlNoiseType.OpenSimplex2:
            result = singleSimplex(fnl, seed, x, y)
        of FnlNoiseType.OpenSimplex2S:
            result = singleOpenSimplex2S(fnl, seed, x, y)
        of FnlNoiseType.Cellular:
            result = singleCellular(fnl, seed, x, y)
        of FnlNoiseType.Perlin:
            result = singlePerlin(fnl, seed, x, y)
        of FnlNoiseType.ValueCubic:
            result = singleValueCubic(fnl, seed, x, y)
        of FnlNoiseType.Value:
            result = singleValue(fnl, seed, x, y)
        #else:
        #    result = 0.0

proc genNoiseSingle(fnl: FnlNoise, seed: var int, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): float =
    case fnl.noiseType
        of FnlNoiseType.OpenSimplex2:
            result = singleOpenSimplex2(fnl, seed, x, y, z)
        of FnlNoiseType.OpenSimplex2S:
            result = singleOpenSimplex2S(fnl, seed, x, y, z)
        of FnlNoiseType.Cellular:
            result = singleCellular(fnl, seed, x, y, z)
        of FnlNoiseType.Perlin:
            result = singlePerlin(fnl, seed, x, y, z)
        of FnlNoiseType.ValueCubic:
            result = singleValueCubic(fnl, seed, x, y, z)
        of FnlNoiseType.Value:
            result = singleValue(fnl, seed, x, y, z)
        #else:
        #    result = 0.0

### fractal FBm

proc genFractalFBm(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat): float =
    var seed = fnl.seed
    var sum: float = 0.0
    var amp = fnl.fractalBounding

    for i in 0 ..< fnl.octaves:
        seed += 1
        var noise = genNoiseSingle(fnl, seed, x, y)
        sum += noise * amp
        amp *= lerp(1.0, fastMin(noise + 1, 2) * 0.5, fnl.weightedStrength)

        x = x * fnl.lacunarity
        y = y * fnl.lacunarity
        amp *= fnl.gain
    
    result = sum

proc genFractalFBm(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): float =
    var seed = fnl.seed
    var sum: float = 0.0
    var amp = fnl.fractalBounding

    for i in 0 ..< fnl.octaves:
        seed += 1
        var noise = genNoiseSingle(fnl, seed, x, y, z)
        sum += noise * amp
        amp *= lerp(1.0, (noise + 1) * 0.5, fnl.weightedStrength)

        x = x * fnl.lacunarity
        y = y * fnl.lacunarity
        z = z * fnl.lacunarity
        amp *= fnl.gain
    
    result = sum

### fractal Ridged

proc genFractalRidged(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat): float =
    var seed = fnl.seed
    var sum: float = 0.0
    var amp = fnl.fractalBounding

    for i in 0 ..< fnl.octaves:
        seed += 1
        var noise = fastAbs(genNoiseSingle(fnl, seed, x, y))
        sum += (noise * -2 + 1) * amp
        amp *= lerp(1.0, 1 - noise, fnl.weightedStrength)

        x = x * fnl.lacunarity
        y = y * fnl.lacunarity
        amp *= fnl.gain
    
    result = sum

proc genFractalRidged(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): float =
    var seed = fnl.seed
    var sum: float = 0.0
    var amp = fnl.fractalBounding

    for i in 0 ..< fnl.octaves:
        seed += 1
        var noise = fastAbs(genNoiseSingle(fnl, seed, x, y, z))
        sum += (noise * -2 + 1) * amp
        amp *= lerp(1.0, 1 - noise, fnl.weightedStrength)

        x = x * fnl.lacunarity
        y = y * fnl.lacunarity
        z = z * fnl.lacunarity
        amp *= fnl.gain
    
    result = sum

### fractal PingPong

proc genFractalPingPong(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat): float =
    var seed = fnl.seed
    var sum: float = 0.0
    var amp = fnl.fractalBounding

    for i in 0 ..< fnl.octaves:
        seed += 1
        var n1 = genNoiseSingle(fnl, seed, x, y) + 1 * fnl.pingPongStrength
        var noise = pingPong(n1)
        sum += (noise - 0.5) * 2 * amp
        amp *= lerp(1.0, noise, fnl.weightedStrength)

        x = x * fnl.lacunarity
        y = y * fnl.lacunarity
        amp *= fnl.gain
    
    result = sum

proc genFractalPingPong(fnl: FnlNoise, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): float =
    var seed = fnl.seed
    var sum: float = 0.0
    var amp = fnl.fractalBounding

    for i in 0 ..< fnl.octaves:
        seed += 1
        var n1 = genNoiseSingle(fnl, seed, x, y, z) + 1 * fnl.pingPongStrength
        var noise = pingPong(n1)
        sum += (noise - 0.5) * 2 * amp
        amp *= lerp(1.0, noise, fnl.weightedStrength)

        x = x * fnl.lacunarity
        y = y * fnl.lacunarity
        z = z * fnl.lacunarity
        amp *= fnl.gain
    
    result = sum


proc getNoise*(fnl: var FnlNoise, x: FnlFloat, y: FnlFloat): float =
    var vx = x
    var vy = y
    transformNoiseCoordinate(fnl, vx, vy)

    case fnl.fractalType:
        of FnlFractalType.FBm:
            result = genFractalFBm(fnl, vx, vy)
        of FnlFractalType.Ridged:
            result = genFractalRidged(fnl, vx, vy)
        of FnlFractalType.PingPong:
            result = genFractalPingPong(fnl, vx, vy)
        else:
            result = genNoiseSingle(fnl, fnl.seed, vx, vy)

proc getNoise*(fnl: var FnlNoise, x: FnlFloat, y: FnlFloat, z: FnlFloat): float =
    var vx = x
    var vy = y
    var vz = z
    transformNoiseCoordinate(fnl, vx, vy, vz)

    case fnl.fractalType:
        of FnlFractalType.FBm:
            result = genFractalFBm(fnl, vx, vy, vz)
        of FnlFractalType.Ridged:
            result = genFractalRidged(fnl, vx, vy, vz)
        of FnlFractalType.PingPong:
            result = genFractalPingPong(fnl, vx, vy, vz)
        else:
            result = genNoiseSingle(fnl, fnl.seed, vx, vy, vz)
    
proc domainWarp*(fnl: var FnlNoise, x: var FnlFloat, y: var FnlFloat): void =
    case fnl.fractalType:
        of FnlFractalType.DomainWarpProgressive:
            domainWarpFractalProgressive(fnl, x, y)
        of FnlFractalType.DomainWarpIndependent:
            domainWarpFractalIndependent(fnl, x, y)
        else:
            domainWarpSingle(fnl, x, y)

proc domainWarp*(fnl: var FnlNoise, x: var float, y: var float): void =
    var xFF = FnlFloat(x)
    var yFF = FnlFloat(y)
    domainWarp(fnl, xFF, yFF)
    x = xFF.float
    y = yFF.float

proc domainWarp*(fnl: var FnlNoise, x: var FnlFloat, y: var FnlFloat, z: var FnlFloat): void =
    case fnl.fractalType:
        of FnlFractalType.DomainWarpProgressive:
            domainWarpFractalProgressive(fnl, x, y, z)
        of FnlFractalType.DomainWarpIndependent:
            domainWarpFractalIndependent(fnl, x, y, z)
        else:
            domainWarpSingle(fnl, x, y, z)

proc domainWarp*(fnl: var FnlNoise, x: var float, y: var float, z: var float): void =
    var xFF = FnlFloat(x)
    var yFF = FnlFloat(y)
    var zFF = FnlFloat(z)
    domainWarp(fnl, xFF, yFF, zFF)
    x = xFF.float
    y = yFF.float
    z = zFF.float